[toc]

本章要点

- ·简介
- ·与外部库链接
- ·本书附带的链接库
- ·堆栈操作
- ·过程的定义和使用
- 使用过程进行程序设计

# 5.1简介

需要阅读本章的理由可以有很多：

- ·读者可能想要学习如何在汇编语言中进行输入输出。
- ·应该了解运行时栈（runtime stack),运行时栈是子过程（函数）调用以及从子过程返回的基本机制
- ·通过本章，将学到如何把大程序划分为模块化的子过程。
- ·本章讲述流程图，流程图是描述程序逻辑的图形工具。
- ·任课老师或许会就本章内容进行测验！

# 5.2与外部库链接

如果读者肯花时间的话，肯定能用汇编语言编写出所有的底层输入输出代码。不过，这就像每次准备外出旅行之前都要重新组装汽车引擎一样，很有趣，但无疑太浪费时间了。在本书后面的第11章中，读者将有机会了解在保护模式下MS-Windows是如何处理输入输出的当有各种各样工具可用的时候，一个全新的世界将展现在面前，那是多么有趣的事情啊。不过，目前在刚开始学习汇编语言基础知识的时候，输入输出必须相当简单才行。5.3节讲述了如何调用本书附带链接库（Irvine32.lib和Irvine16.lib)中的过程（子过程）。本书附带的链接库可在本书的Web站点上找到（www.asmirvine.com),作者将定期进行更新。
链接库Irvine32.lib用于32位保护模式下编写的程序，其中进行输入输出的过程调用了MS-Windows API。库Irvine16.lib用于16位实地址模式下编写的程序，其中进行输入输出的过程调用了MS-DOS中断。

## 5.2.1背景知识

链接库（link library)是一个文件，其中包含了已经编译成机器码的过程。库可以由一个或多个源代码文件构成，这些文件被汇编成目标文件，然后这些目标文件被插入到一个特定格式的文件一库中，链接实用工具能够识别这种特定的文件格式。假设程序要调用名为WriteString的过程在控制台上显示一个字符串，那么程序源码中就必须包含下面的PROTO伪指令声明WriteString过程：

```
WriteString PROTO
```

接下来，用一条CALL指令执行WriteString过程：

```
call WriteString
```

汇编器汇编程序的时候，为CALL指令的目的地址留出空白，该空白随后将由链接器填充为实际的目的地址。链接器在链接库中查找WriteString这个名字，并从库中把相应的机器指令复制到程序的可执行文件中，然后把WriteString在可执行文件中的实际地址插入到CALL指令中为目的地址留出的空白处。如果试图调用不在链接库中的过程，链接器会产生一条错误消息并拒绝生成可执行文件。
**链接器的命令行选项**：链接器程序把程序的目标文件和其他目标文件以及库文件合并起来。例如下列命令将hello.obj,irvine32.lib以及kernel32.lib相链接：

```
link hello.obj irvine32.lib kerne132.1ib
```

链接32位程序：下面解释一下链接32位程序时使用的链接库kernel32.lib。kernel32.lib文件是Microsoft Windows平台软件开发包（platform SDK)的一部分，它包含了kernel32.dll中的操作系统函数的链接信息。kernel32.dll是Microsoft Windows操作系统的一个基本组件，称为动态链接库（dynamic link library),其中包含了执行基于字符输入输出功能的可执行函数。读者可以把kernel32.lib想像成通向kernel32.dll的桥梁，如下图所示：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/root/image.6nw71twyqrk0.webp)

本书第1章到10章中的例子都使用Irvine32.lib链接库。第11章讲述程序如何直接使用链接库kernel32.lib。



# 5.3 本书附带的链接库

## 5.3.1 概述

表5.1列出了本书附带的Irvine32和Irvine16链接库中常用的过程。尽管库Irvine16.lib是用于16位（实地址模式）程序的，它还是使用了32位的寄存器。Irvine32.lib和Irvine16.lib同时包含本节中提到的大多数过程。对那些只有Irvine32.lib才有的过程在描述后以“*”进行了标注。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/root/image.2axg0vizhts0.webp)

### 控制台窗口：

控制台窗口（console window)是MS-Windows创建的文本窗口要显示一个控制台窗口，单击菜单“开始运行”，输人cmd(Windows2000/XP)或command(Windows 95/98),然后回车，控制台窗口默认将显示一个命令行提示符。在Windows2000/XP下，单击控制台窗口左上角的系统菜单，选择“属性”，可以修改窗口的大小、字体以及颜色。在Windows95/98下，窗口的大小只能从几个默认行数值中进行选择所有Windows版本控制台窗口的大小默认MS-DOS一样，都是25行乘以80列。可以使用mode命令修改行数和列数，下例将控制台窗口的大小设为30行40列：

```
mode con cols=40 lines=30
```

### 重定向输入输出

库Irvine32和Irvine16都向控制台窗口写输出数据，链接Irvine16时还有一个特别之处：准输入输出的重定向也就是说，在DOS和Windows命令提示符下其输出可以写人到文件而不是控制台窗口中。下面的例子演示了重定向是如何工作的：假设一个程序sample.exe要向标准输出（控制台）写数据，可以在命令行提示符下使用如下命令把它的输出重定向到一个名为output.txt的文件中：

```
sample>output.txt
```

类似地，如果该程序要读取键盘输入（标准输入）,也可以让它从一个名为input.txt的文件中读：

```
sample < input . txt
```

可以使用一条命令同时重定向输入和输出

```
sample<input.txt>output.txt
```

还可以使用管道符（1)把progl.exe的输出送到prog2.exe的输入：

```
prog1|prog2
```

下例把progl.exe的输出送到prog2.exe的输入，然后再把prog2.exe的输出重定向到文件output.txt中：

```
prog1|prog2>output.txt
```

下面的例子中prog1.exe从input.txt中读取输入，然后把输出送prog2.exe,prog2.exe把自己
的输出重定向到output.txt中：

```
rog1 < input . txt | prog2 > output . txt
```

## 5.3.2过程的描述

CloseFile(仅Irvine32):CloseFile过程关闭一个以前打开的文件。文件是以文件句柄（handle)标识的，文件句柄通过EAX传递。如果文件被成功关闭，EAX中返回值为非零值。使用举例：

```
mov eax,fileHandle
call CloseFile
```

### Clrscr:

Clrscr过程用于清除控制台窗口的内容，它通常在程序的开始和结束时使用，如果在
其他时刻调用，最好在调用CIrscr之前暂停一下程序（调用WaitMsg),以便用户在屏幕擦除之前能够看清已有的信息，使用举例：

```
call waitMsg
;"Press any key..."
call Clrscr
```

### Crlf:

Crlf过程把光标定位到控制台窗口下一行的开始，该功能是通过向标准输出写包含ODh和0Ah两个字符的字符串来实现的，使用举例：

```
call Crlf
```

### CreateOutputFile(仅Irvine32):

CreateOutputFile过程创建一个磁盘文件并以输出模式打开使用时通过EDX传递要创建的文件名的偏移地址。过程返回时，如果文件成功创建，则EAX包含有效的文件句柄（一个32位整数）。如果创建失败，EAX中的值是INVALID_HANDLE_VALUE(一个预定义的常量）。使用举例：

```
datame BYTE "newfile.txt",0
handle DWORD ?
.code
mov edx , OFFSET filename
call CreateOutputFile
cmp eax,INVALID_HANDLE_VALUE
;显示错误信息
mov handle , eax
```

注意：前面的代码比较EAX和预定义常量INVALID_HANDLE_VALUE是否相等。如
果相等，则跳转到名为file_error的标号处。CMP和JE指令在第6章介绍，这里给出的
错误处理代码是为了完整起见。

### Delay:

Delay过程暂停程序指定的毫秒数。在调用该程之前需要把EAX初始化为预期暂停
的时间，单位以毫秒计算。使用举例：

```
mov eax,1000	;1s
call Delay
```

(Irvine16.lib中的本过程无法在WindowsNT/2000/XP操作系统中使用。）
DumpMem:DumpMem过程以十六进制数格式在控制台窗口中显示一块内存的内容，在调用之前，需要将ESI设置为内存的开始地址，ECX设置为元素数目，EBX设置为元素尺寸（1=byte2=word,4=doubleword)。下面的语句显示一个名为array的包含11个双字变量的数组：

```
.data
array DWORD 1,2,3,4,5,6,7,8,9,0Ah,0Bh
.code
main PROC
mov esi, OFFSET array
;起始地址
mov ecx, LENGTHOF array
;元素数目
mov ebx, TYPE array
;格式为双字
call DumpMem
```

上例的输出如下：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/root/image.5ykbjn8yalo0.webp)

### DumpRegs:

DumpRegs过程以十六进制数格式显示EAX,EBX,ECX,EDX,ESI,EDI,EBP,
ESP,EIP,EFL(EFLAGS)寄存器的内容，并同时显示进位、符号、零和溢出标志的值。使用举例：

```
call DumpRegs
```

例子的输出：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/root/image.4nmz21cgg1k0.webp)

显示的EIP值是紧跟在call DumpRegs语句后面的指令的偏移地址，DumpRegs函数在调试程序的时候可能非常有用，因为它能够显示程序运行时CPU的状态快照。该过程没有输入参数和返回值。

### GetCommandTail

GetCommandTail过程把程序的命令行复制到一个以空字符结尾的字符串中。如果命令行为空，则设置进位标志，否则清除进位标志。这个过程很有用，因为它允许用户通过命令行传递信息。例如，假设程序Encrypt读取输入文件filel.txt并产生一个输出文件file2.txt,那么用户可以在程序运行时通过命令行传递这两个文件名：

```
Encrypt filel.txt file2.txt
```

在开始运行后，程序Encrypt可以调用GetCommandTail返回这两个文件名。调用GetCommandTail时，EDX中必须存放着一个至少包含129字节的数组的偏移：

```
.data
cmdTail BYTE 129 DUP(0)
;空缓冲区
.code
mov edx , OFFSET buffer ;填充缓冲区
```

### GetMaxXY(仅Irvine32):

GetMaxXY过程返回控制台窗口缓冲区的大小。如果控制台窗口缓冲区的大小大于可见的窗口部分，控制台窗口会自动出现滚动条。GetMaxXY无输人参数。返回时，DL存放窗口缓冲区的列数，DH存放窗口缓冲区的行数。该过程要求行数和列数都不能大于255,实际中有可能窗口缓冲区的行列大小会超过255,不过这种情况比较少见。使用举例

```
.data
rows BYTE ?
cols BYTE ?
.code
call GetMaxXY
mov rows , dh
mov cols , d1
```

### GetMseconds:

GetMseconds过程返回从午夜开始计算的逝去的毫秒数，返回值在EAX中，这个过程可用来测量两个事件之间的时间间隔。该过程不需要输入参数。在下例中，程序首先调用该过程并保存其返回值，然后执行循环。在循环结束后，再次调用GetMseconds过程并把这两次调用的返回值相减，这样就得到了以毫秒计算的循环执行的大致时间：

```
.data
startTime DWORD ?
.code
call GetMseconds
mov startTime , eax
L1:
;(循环体）
loop L1
call GetMseconds
sub eax,startTime
;EAX=以毫秒计算的循环时间
```

### GetTextColor(仅Irvine32):

GetTextColor返回当前控制台窗口的前景和背景色。该过程无输入参数。返回值在AL中，高4位是背景色，低4位是前景色。使用举例：

```
.data
color BYTE ?
.code
call GetTextColor
mov color,AL
```

### Gotoxy:

Gotoxy把光标定位在在控制台窗口中指定的行列位置上。默认情况下，控制台窗口的X坐标范围是0~79,Y坐标范围是0~24。调用Gotoxy时，需要把Y坐标（行）置于DH中，将X坐标（列）置于DL中。使用举例：

```
mov dh, 10
;行10
mov d1 , 20
;列20
call Gotoxy
;定位光标
```

用户可能需要重置控制台窗口，因此可调用GetMaxXY来获得行和列的当前值。

### IsDigit

:IsDigit过程确定AL中的字符是否是有效的十进制数字（0~9)。调用该过程时通过AL传递ASCII字符。如果AL中的字符是有效的十进制数字，则零标志置位，否则零标志清零。使用举例：

```
mov AL,somechar
call IsDigit
jz digit_found
```

(JZ指令在零标志置位时跳转到目的标号处，将在6.3.2节介绍。）

### MsgBox(仅Irvine32):

MsgBox过程显示一个图形界面的弹出消息框，可以设置标题栏要显示的文字。调用时通过EDX传递要显示的字符串的偏移地址，字符串将显示在消息框的中央，或者，还可以通过EBX传递要显示在标题栏中的字符串的偏移地址。要想标题栏为空，把EBX清零即可。使用举例：

```
.data
caption db "Dialog Title", 0
HelloMsg BYTE "This is a pop-up message box.", Odh, Oah
BYTE"Click OK to continue...",0
code
moy edx , OFFSET Caplions g
call MsgBox
```

例子输出：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/root/image.67gix908xww0.webp)

### MsgBoxAsk(仅lrvine32)

:MsgBoxAsk过程显示一个带一个Yes按钮和一个No按钮图形界面的弹出消息框。调用时通过EDX传递要显示的作为问题的字符串的偏移地址，字符串将显示在消息框的中央。或者，还可以通过EBX传递要显示在标题栏中的字符串的偏移地址。要想标题栏为空，把EBX清零即可。MsgBoxAsk在EAX中返回一个整数值：IDYES(等于6)和IDNO(等于7),通过该返回值可以知道用户选择了哪个按钮。使用举例：

```
,data
caption BYTE "Survey Completed",0
question BYTE "Thank you for completing the survey."
BYTE Odh, Oah
BYTE"Would you like to receive the results?",0
results BYTE "The results will be sent via email.", Odh, Oah, 0
.code
mov ebx,OFFSET caption
mov edx, OFFSET question
call MsgBoxAsk
;检查EAX中的返回值
```

例子输出：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/root/image.5g33ivpq0bc0.webp)

### OpenlnputFile(仅Irvine32)

:OpenInputFile过程打开一个已存在的磁盘文件以进行输入。通过EDX传递要打开的文件名的偏移地址。过程返回时，如果文件成功创建，则EAX包含有效的文件句柄；如果创建失败，则EAX中的返回值是INVALID_HANDLE_VALUE(一个预定义的常量）。使用举例：

```
data BY
handle Dworn , " myfile . txt " , 0
.code
mov edx,OFFSET filename
call OpenInputFile
cmp eax,INVALID_HANDLE_VALUE
:显示错误信息
je file_error
;保存文件句柄
```

注意：前面的代码比较EAX和预定义常量INVALID_HANDLE_VALUE是否相等。如果相等，则跳转到名为file_error的标号处。CMP和JE指令在第6章介绍，这里给出的错误处理代码是为了完整起见。

### ParseDecimal32:

ParseDecimal32过程把无符号整数字符串转换为一个32位的二进制数字符串中非数字字符前面的所有数字都将被转换，开头的空格将被忽略。调用时通过EDX传递字符串的偏移地址，ECX传递字符串的长度，转换后的二进制值在EAX中返回。使用举例：

```
.dat
buffer BYTE "8193"
bufSize=($-buffer)
.code
mov edx , OFFSET buffe
call ParseDecima132
;返回EAX
```

该过程对进位标志的影响请参见ReadDec过程的描述。

### Parselnteger32:

ParseInteger32过程把有符号整数字符串转换为一个32位的二进制数。字符串中非数字字符前面的所有数字都将被转换，开头的空格将被忽略。调用时通过EDX传递字符串的偏移地址，ECX传递字符串的长度，转换后的二进制值在EAX中返回。使用举例：

```
buffer BYTE "-8193'
bufsize=(/$-buffer)
.code
mov edx,OFFSET buffer
mov ecx,bufsize
;返回EAX
```

字符串开头可以有符号字符：加号（表示正数）或负号（表示负数）,但符号字符后必须跟十进制数字。如果转换后的值无法用32位有符号整数（范围：-2147483648~+2147483647表示该过程将设置溢出标志并在控制台上显示一条出错信息。

### Random32:

Random32过程生成32位的随机整数并在EAX中返回重复调用Random32会生成一系列的伪随机整数（pseudorandom integer)随机数的生成是通过调用一个简单的函数完成的，该函数需要一个输入，称为种子（seed)。函数根据公式对种子进行运算生成第一个随机值生成下一个随机数的时候使用上次生成的随机数作为种子。由此看来，我们使用“随机”（random)这个术语的时候表示的是伪随机（pseudorandom)。使用举例：

```
.data
randval DWORD ?
.code
call Random32
mov randval,eax
```

Random32过程在Irvine16.lib中也有，同样在EAX中返回生成的随机数

### Randomize:

Randomize过程初始化Random32和RandomRange过程使用的种子值。该种子值使用的是当前时间，精确到1/100s。这保证了调用Random32和RandomRange的程序每次运行时，每次生成的随机数序列都不同并且唯一。使用的时候只需在程序开始处调用一次Randomize即可。例如下例中生成了10个随机整数：

```
call Randomize
mov ecx,10
L1:call Random32
;这里使用或显示EAX中的随机数
Loop L1
```

### RandomRange:

RandomRange过程生成一个在范围0到（n-1)之间的随机整数，其中n是通过EAX寄存器传递的参数，生成的随机数在EAX中返回例如，以下语句生成一个0~4999之间的随机整数并存放在EAX中：

```
randval DWORD ?
.code
mov eax, 5000
call RandomRange
mov randval,eax
```

### ReadChar:

ReadChar过程从标准输入读取一个字符并在AL寄存器中返回，输入的字符不在控制台窗口中回显。使用举例：

```
.data
char BYTE ?
.code
call ReadChar
mov char,al
```

如果用户按下了扩展键，如功能键，光标键，Ins,Del等，该过程将AL清零，AH中存放着扩展按键的扫描码。扫描码列表可在本书的前言中找到。EAX的高16位保留。

### ReadDec:

ReadDec过程读取键盘输入的无符号32位十进制整数并在EAX中返回。该过程忽略输入字符串开头的空格，从字符串的开始用所有有效的数字字符计算转换后的数字，遇到非