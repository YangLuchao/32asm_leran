[toc]

本章要点

- 结构
- 宏
- 条件汇编伪指令
- 定义重复块

# 10.1 结构

==结构（structure)是逻辑上相互关联的一组变量的模板或模式，结构中的单个变量称为域（field）程序的语句可以把结构作为一个实体进行访问，也可以对结构的单个域进行访问。==结构通常包含不同类型的域。联合（union)同样也是把多个标识符组合在一起，不过这些标识符共用同一块内存区域，联合在10.1.7节介绍
结构为归集数据以及在过程间进行传递提供了方便。假设一个过程的输入参数是由20个与磁盘驱动器相关的数据项构成的，调用过程时要想正确地传递所需参数是非常困难的，相反应该把所有相关的数据放在一个结构中，然后向过程传递结构的地址，这只需使用极少的堆栈空间（一个地址）,被调用过程同时还能够修改结构的内容。
汇编语言中的结构与C/C++中的结构基本相同，对于WindowsAPI库中的任何结构，不用费多大劲进行转换就可以使之在汇编语言中工作。一个好的调试器如Microsoft Visual Studio在运行时能够显示结构的单个域的名称和内容。

### COORD结构

WindowsAPI定义的COORD结构用于标识屏幕上的X坐标和Y坐标。在该结构中，域X相对结构开始的偏移是0，域Y相对于结构开始的偏移是2:

```assembly
COORD STRUCT
	X WORD ?	;偏移00
	Y WORD ?	;偏移02
COORD ENDS
```

结构的使用包含下面三个顺序步骤：

1. 定义结构。
2. 声明一个或多个该结构类型的变量，称为结构变量（structure variable)。
3. 写运行时指令访问结构的域。

## 10.1.1 定义结构

==结构使用STRUCT和ENDS伪指令定义。==在结构内部，使用与定义普通变量一样的格式来定义域。基本格式如下所示：

```assembly
名字	STRUCT
	域的声明
名字	ENDS
```

### 域的初始化

如果结构的域有初始值，在定义结构变量时这些初始值就成了结构变量域的默认值。结构中可使用多种类型的初始值：

- 未定义：使用`?`表示域内容未定义。
- 字符串：用引号包围的字符串。
- 整数：整数常量或整数表达式。
- 数组：当域是一个数组时，可使用DUP操作符初始化数组元素。

下面的Employee结构描述了雇员的信息，包含了多个域，如身份证号、姓名、服务年限以及薪金的历史值数组等。下面的结构定义应该放在任何Employee类型变量的声明之前：

```assembly
Employee STRUCT
	IdNum 			BYTE 	"000000000"
	LastName 		BYTE 	30 DUP(0)
	Years 			WORD 	0
	SalaryHistory 	DWORD 	0,0,0,0
Employee ENDS
```

下图是该结构的内存布局的线性排列表示。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.7aop2jshvv40.webp)

### 结构中域的对齐

==为了取得最佳的I/O性能，结构的成员应该根据其数据类型进行对齐，否则CPU在访问结构的成员时就要花费更多的时间。==例如，双字成员应该对齐在双字地址边界上。表10.1列出了Microsoft C/C++编译器对不同的数据类型对齐方式的处理。在汇编语言中，ALIGN伪指令设置下一个域或变量的地址对齐方式：

```assembly
ALIGN datatype
```

在下例中，myVar对齐在双字地址边界上：

```assembly
.data
	ALIGN DWORD
	myVar DWORD ?
```

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.605j0or8ca80.webp)

下面来正确地定义Employee结构：使用ALIGN伪指令使得成员Years对齐在字边界上、成员SalaryHistory对齐在双字边界上，各个域的大小在注释中给出：

```assembly
Employee STRUCT
	Idnum 		BYTE "000000000"	;9
	Lastname 	BYTE 30 DUP(0)	;30
	ALIGN WORD	;增加1字节
	Years		WORD0			;2
	ALIGN DWORD	;增加2字节
	SalaryHistory DWORD 0,0,0,0	;16
Employee ENDS					;总计60字节
```

## 10.1.2 声明结构变量

可以声明结构变量(structure variable)并用特定的值进行初始化。下面是声明的语法，其中结构类型(structureType)是已经使用STRUCT伪指令定义了的结构：

```assembly
identifier structureType < initializer-list >
```

其中标识符名(identifier)和MASM中的其他变量名遵循同样的命名规则。初始值列表
(initializer-list)是可选的。如果使用了初始值列表，那么列表应该是以逗号分隔的并且能够与相应的结构成员数据类型匹配的汇编期常量：

```assembly
initializer [, initializer] ...
```

==如果声明的时候使用的是尖括号，结构变量的各个域包含的是结构定义时给定的初始值。==还可以插入新值初始化结构变量的某些域，初始值列表中的值按照从左到右的顺序对结构的相应成员依次（按结构声明时的顺序）赋值。下面以COORD和Employee结构为例演示这两种方法：

```assembly
.dat
point1 COORD 	<5,10>		;X=5,Y=10
point2 COORD 	<20>		;X=20,Y=?
point3 COORD 	<>			;X=?,Y=?
worker Employee <>			;默认的初始值
```

覆盖部分域默认值都是可能的，下面的声明只覆盖了Employee结构的IdNum域：

```assembly
person1 Employee <"555223333">
```

另一种可选的格式是使用大括号而不是尖括号：

```assembly
person2 Employee {"555223333"}
```

在字符串域的初始化值比域短时，其余的位置以空格填充，字符串的末尾不会自动插入空字符。可以插入逗号作为占位符跳过对结构中某些域的初始化。例如，下面的语句跳过了IdNum域初始化LastName域：

```assembly
person3 Employee <"dJones">
```

对于结构中数组类型的域，可以使用DUP操作符初始化某些或全部数组元素，如果初始化值比域短，那么剩余位置将用0填充。例如，下面的语句初始化SalaryHistory的前两个值并把其余的元素设为0:

```assembly
person4 Employee <,,,,2 DUP(20000)>
```

### 结构数组

可以使用DUP操作符声明结构数组。在下例中，AlPoints的每个元素的域X和域Y都被初始化成0

```assembly
NumPoints = 3
A11Points COORD NumPoints DUP ( < 0 , 0 > )
```

### 结构变量的对齐

为取得最佳性能，结构变量应根据结构中类型尺寸最大的成员的类型进行对齐。Employee 结构包含的最大的类型尺寸是DWORD,因此下面的定义就根据DWORD对齐结构变量：

```assembly
.data
ALIGN DWORD
person Employee <>
```

## 10.1.3 引用结构变量

TYPE和SIZEOF操作符既可用于结构变量也可用于结构名。继续以前面的Employee结构举例：

```assembly
Employee STRUCT
	Idnum BYTE	"000000000"	;9
	Lastname BYTE 30 DUP(0)	;30
	ALIGN WORD				;增加1字节
	Years WORD 0			;2
	ALIGN DWORD				;增加2字节
	SalaryHistory DWORD 0,0,0,0	;16
Employee ENDS				;总计60字节
```

给定数据定义：

```assembly
.data
worker Employee <>
```

下面的每个表达式都返回同样的值：

```assembly
TYPE 	Employee		;60
SIZEOF 	Employee		;60
SIZEOF 	worker			;60
```

#### 回忆一下

TYPE操作符返回标识符的存储类型（BYTE,WORD和DWORD等）占用的字节数，LENGTHOF操作符返回数组元素的数目，SIZEOF操作符返回LENGTHOF和TYPE的乘积，这些都在4.3节介绍过了。

### 域（成员）的引用

直接引用单个域时要求使用结构或结构变量作为修饰词。同样以Employee结构为例，下面的常量表达式可在汇编时生成：

```assembly
TYPE 		Employee.SalaryHistory		;4
LENGTHOF 	Employee.SalaryHistory		;4
SIZEOF 		Employee.SalaryHistory		;16
TYPE 		Employee.Years				;2
```

下面语句在运行的时候引用Employee类型的结构变量worker:

```assembly
.data
	worker Employee <>
.code
	mov dx,worker.Years
	mov worker.SalaryHistory,20000	; First Salary
	mov [worker.SalaryHistory+4],30000	; Second Salary
```

使用OFFSET操作符：可以使用OFFSET操作符获取结构变量中域的偏移地址：

```assembly
mov edx,OFFSET worker.LastName
```

### 间接操作数和变址操作数

间接操作数允许使用寄存器(如ESI)来寻址结构数据，这种方法在向过程传递结构地址或使用结构数组时提供了非常大的灵活性。使用间接操作数引用结构时要求使用PTR操作符：

```assembly
mov esi,OFFSET worker
mov ax, (Employee PTR [esi]).Years
```

下面的语句无法通过编译，因为Years本身并不足以确定某个特定的结构：

```assembly
mov ax,[esi].Years	;无效
```

### 变址操作数

可以使用变址操作数访问结构数组。假设department是一个包含5个Employee对象的数组，下面的语句访问其索引位置1处的Employee对象的Years域：

```assembly
.data
	department Employee 5 DUP (<>)
	mov 	esi,TYPE Employee		;index=1
	mov 	department[esi].Years,4
```

### 循环遍历数组

可以使用循环及间接寻址、变址寻址方式来操纵结构数组。下面的程序(AllPoints.asm)为AllPoints数组赋坐标值：

```assembly
TITLE Loop Through Array	(A11Points.asm)
INCLUDE Irvine32.inc
NumPoints = 3
.data
	ALIGN WORD
	AllPoints COORD NumPoints DUP(<0,0>)
.code
main PROC
	mov edi,0			;数组索引
	mov ecx,NumPoints	;循环计数器
	mov ax,1			;起始的x和Y坐标值
L1: 
	mov (COORD PTR A11Points[edi]).X,ax
	mov (COORD PTR A11Points[edi]).Y,ax
	add edi,TYPE COORD
	inc ax
	loop L1
	exit
	main ENDP
END main
```

### 结构成员对齐与否对性能的影响

前面曾经说过，处理器访问对齐的结构成员时效率更高，那么未对齐的结构域对于性能究竟有多大的影响呢？下面使用本章前面给出的两个版本的Employee结构进行一个简单的测试。我们重命名第一个结构，以便两个结构能用在同一个程序中：

```assembly
EmployeeBad STRUCT
	idNum 			BYTE	"000000000"
	LastName 		BYTE 	30 DUP(0)
	Years 			WORD 	0
	SalaryHistory 	DWORD	0,0,0,0
EmployeeBad ENDS
Employee STRUCT
	Idnum 			BYTE 	"000000000"
	Lastname 		BYTE 	30 DUP(0)
	ALIGN WORD
	Years 			WORD 	0
	ALIGN DWORD
	SalaryHistory 	DWORD 	0,0,0,0
Employee ENDS
```

下面的代码首先获取系统时间，接着执行一个循环，在循环中访问结构的域，然后再计算用去的时间。变量emp可以声明成Employee或EmployeeBad对象：

```assembly
.data
	ALIGN DWORD
	startTime DWORD ?	;对齐startTime
	emp Employee <>		;或定义为：emp EmployeeBad<>
.code
	call GetMSeconds	;获取起始时间
	mov startTime,eax
	mov ecx,OFFFFFFFFh	;循环计数器
L1: 
	mov emp.Years, 5
	mov emp.SalaryHistory,35000
	loop L1
	call GetMSeconds	;获取结束时间
	sub eax,startTime
	call WriteDec		;显示用去的时间
```

对于这个简单的测试程序(Structl.asm),使用对齐的Employee的版本用去的时间是6141ms,使用未对齐的EmployeeBad的版本用去的时间是6203ms,时间差异不大（62ms),这可能是处理器的缓存使得未对齐的结构成员对于性能的影响减小了。

## 10.1.4 例子：显示系统时间

MS-Windows提供了设置屏幕光标位置的控制台函数和获取系统时间的函数。要使用这两个函数，必须首先创建两个预定义结构——COORD和SYSTEMTIME:

```assembly
COORD STRUCT
	X WORD ?
	Y WORD ?
COORD ENDS
SYSTEMTIME STRUCT
	wYear 		WORD ?
	wMonth 		WORD ?
	wDayOfweek 	WORD ?
	wDay 		WORD ?
	wHour 		WORD ?
	wMinute 	WORD ?
	wSecond 	WORD ?
	wMilliseconds WORD ?
SYSTEMTIME ENDS
```

这两个结构都是在SmallWin.inc文件中定义的，SmallWin.inc文件位于汇编器的INCLUDE目录中，Irvine32.inc中已经引用了该文件。要想获取系统时间（本地时区时间）,可以调用MS-Windows的GetLocalTime函数并向它传递一个SYSTEMTIME结构变量的地址：

```assembly
.data
	sysTime SYSTEMTIME <>
.code
INVOKE GetLocalTime, ADDR sysTime
```

函数在SYSTEMTIME结构中返回准确的时间值，例如：

```assembly
movzx 	eax,sysTime.wYear
call 	WriteDe
```

SmallWin.inc文件是作者根据C和C++程序员使用的Microsoft Windows头文件改写的，
其中包括了小部分与应用程序可能调用的函数相关的结构和函数原型定义。
在Win32控制台程序想要产生屏幕输出时，它需要调用GetStdHandle函数获取标准控制台输出句柄（一个整数）:

```assembly
.data
	consoleHandle DWORD ?
.code
	INVOKE 	GetStdHandle,STD_OUTPUT_HANDLE
	mov 	consoleHandle,eax
```

(常量STD_OUTPUT_HANDLE在SmallWin.inc中定义。）
欲设置屏幕光标的位置，应调用MS-Windows的SetConsoleCursorPosition函数，并向函数传递控制台输出句柄以及一个包含字符X和Y坐标的COORD类型的结构变量：

```assembly
.data
	XYPOS COORD <10,5>
.code
	INVOKE SetConsoleCursorPosition,consoleHandle,XYPos
```

### 程序清单

下面的程序（ShowTime.asm)获取当前的系统时间并在指定的屏幕位置上显示，该程序只能在保护模式下运行：

```assembly
TITLE Structures (ShowTime.ASM)
INCLUDE Irvine32.inc
.data
	sysTime 		SYSTEMTIME <>
	XYPos 			COORD 	<10,5>
	consoleHandle	DWORD 	?
	colonStr 		BYTE	":",0
.code
main PROC
;获取Win32控制台的标准输出句柄
INVOKE GetStdHandle,STD_OUTPUT_HANDLE
	mov 	consoleHandle,eax		;设置光标位置并获取系统时间
	INVOKE 	SetConsoleCursorPosition,consoleHandle,XYPos
	INVOKE 	GetLocalTime, ADDR sysTime	;显示系统时
	movzx 	eax,sysTime.whour			;小时
	call 	WriteDec
	mov 	edx,OFFSET colonStr			;":"
	call 	WriteString
	movzx 	eax,sysTime.wMinute			;分钟
	call 	WriteDec
	call 	WriteString
	movzx 	eax,sysTime.wSecond			;秒
	call 	WriteDec
	call 	Crlf
	call 	waitMsg						;"Press any key..."
	exit
	main 	ENDP
END main
```

程序中使用的下列定义来自SmallWin.inc(Irvine32.inc中自动包含了这个文件）:

```assembly
STD_OUTPUT_HANDLE EQU -11
SYSTEMTIME STRUCT...
COORD STRUCT...
GetStdHandle PROTO,
		nStdHandle:DWORD
GetLocalTime PROTO,
		IpSystemTime:PTR SYSTEMTIME
SetConsoleCursorPosition PROTO,
		nStdHandle:DWORD ,
		coords:COORD
```

下面是程序的屏幕输出示例，时间是下午12:16。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.7derlgminmg0.webp)

## 10.1.5 结构的嵌套

结构中可以包含其他结构的实例，这种结构称为嵌套结构。例如，一个Rectangle结构可通过屏幕左上角和右下角的坐标来定义，这两个坐标都是COORD结构：

```assembly
Rectangle STRUCT
	UpperLeft COORD <>
	LowerRight COORD <>
Rectangle ENDS
```

Rectangle变量声明的时候可以不初始化，也可以覆盖（初始化）某个COORD域，下面是几种初始化的语法格式：

```assembly
rect1 Rectangle <>
rect2 Rectangle	{}
rect3 Rectangle	{{10,10},{50,20}}
rect4 Rectangle <<10,10>, <50,20>>
```

下面是对嵌套结构的域的直接引用：

```assembly
mov rect1.UpperLeft.X,10
```

也可以使用间接操作数来访问嵌套结构的某个域。下例中，我们把ESI指向的结构的左上角坐标中的Y坐标赋值为10:

```assembly
mov esi,OFFSET rect1
mov (Rectangle PTR [esi]).UpperLeft.Y,10
```

OFFSET操作符能够返回指向单个结构域的指针，其中包括嵌套域：

```assembly
mov edi,OFFSET rect2.LowerRight
mov (COORD PTR [edi]).X,50
mov edi,OFFSET rect2.LowerRight.X
MOV WORD PTR [edi], 50
```

## 10.1.6 例子：醉汉走路

历年来，有很多程序设计教科书中都包含一个称为“醉汉走路”（Drunkard's Walk)的习题，要求程序模拟一个喝醉了酒还未清醒的教授在回家路上的行走路径。读者可以使用随机数发生器为教授踏出的每一步选择一个方向。在现实中，需要做必要的检查以确保教授不会因为转变方向而掉进校园的湖中，但这里我们不用担心这一点。假设教授从一个假想表格的中央开始行走，其中每个正方形代表向东南西北的一步，教授在格子中沿随机路径行走（见图10.1)。
将要给出的程序使用COORD结构来记录教授踏出的每一步，所有步都被存储在一个包含COORD对象的数组中：

```assembly
WalkMax = 50
Drunkardwalk STRUCT
	path COORD WalkMax DUP(<0,0>)	;域名叫path，CORD类型，50次重复
	pathsUsed WORD 0				;总共走了多少步
Drunkardwalk ENDS
```

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.3fm71kg2ggs0.webp)

WalkMax是一个决定模拟教授行走总步数的常量，pathsUsed域表示当程序循环结束时教授总共走了多少步。当教授踏出每一步的时候，其位置被存储在一个COORD对象中并插入到path数组的下一个可用位置中去。程序在屏幕上显示了这些坐标。下面是完整的程序清单：

```assembly
TITLE Drunkard's Walk	(Walk.asm)
; Drunkard's walk program. The professors starts at
; coordinates 25 , 25 and wanders around the immediate area .
INCLUDE Irvine32.inc
NalkMax = 50
Startx = 25
StartY = 25
Drunkardwalk STRUCT
	path COORD WalkMax DUP(<0,0>)
	pathsUsed WORD 0
DrunkardWalk ENDS
DisplayPosition PROTO currX:WORD,currY:WORD
.data
	awalk Drunkardwalk <>
.code
main PROC
	mov 	esi,OFFSET aWalk
	call 	TakeDrunkenWalk
	exit
main ENDP
TakeDrunkenwalk PROC
			LOCAL currX:WORD,currY:WORD
; Take a walk in random directions ( north , south , east ,
; west).
; Receives : ESI points to a Drunkardwalk structure
; Returns : the structure is initialized with random values
	pushad
; Use the OFFSET operator to obtain the address of
; path , the array of COORD objects , and copy it to EDI .
	mov edi,esi
	add edi,OFFSET DrunkardWalk.path
	mov ecx,WalkMax			;循环计数器
	mov currX,StartX		;当前的X坐标位置
	mov curry, Starty		;当前的Y坐标位置
Again:
; Insert current location in array .
	mov ax,currx
	mov (COORD PTR [edi]).X,ax
	mov ax,curry
	mov (COORD PTR [edi]).Y,ax
	INVOKE DisplayPosition, currx, curry
	mov eax,4				;选择一个方向（0-3)
	call RandomRange
	.IF eax == 0			;北
		dec curry
	.ELSEIF eax == 1		;南
		inc curry
	.ELSEIF eax == 2		;西
		dec currx
	.ELSE					;东（EAX=3)
		inc currx
	.ENDIF
	add edi,TYPE COORD		;指向下一个COORD
	loop Again
Finish:
	moy (DrunkardWalk PTR [esi]).pathsUsed,WalkMax
	popad
	ret
TakeDrunkenWalk ENDP
DisplayPosition PROC currX:WORD,currY:WORD
; Display the current X and Y positions .
.data
	commaStr BYTE ",",0
.code
	pushad
	movzx 	eax,currx			;当前位置X
	call 	WriteDec
	mov 	edx,OFFSET commaStr ;字符串“，"
	call 	WriteString
	movzx	eax,curry			;当前位置Y
	call 	WriteDec
	call 	Crlf
	popad
	ret
DisplayPosition ENDP
END main
```

### TakeDrunkenWalk过程

下面仔细看一下TakeDrunkenWalk过程，它接收一个指向DrunkWalk结构的指针（ESI)。过程使用OFFSET操作符计算出path数组的偏移地址并复制到EDI中：

```assembly
mov edi,esi
add edi,OFFSET Drunkardwalk. path
```

该教授初始的X和Y位置（StartX和StartY)都被设置为25,相当于在一个假想的50×50
的表格的中央。首先初始化循环计数器：

```assembly
mov ecx, Walkmax		;循环计数器
mov currx,StartX		;当前X坐标
mov currY,StartY		;当前Y坐标
```

在循环的开始，path数组的前两个项被初始化：

```assembly
Again:		
;在数组中插入当前的位置
	mov ax,currx
	mov (COORD PTR [edi]).X,ax
	mov ax,curry
	mov (COORD PTR [edi]).Y,ax
```

在行走结束时，一个计数值被存入到pathsUsed域中，它代表究竟走了多少步：

```assembly
Finish:
mov (Drunkardwalk PTR [esi]).pathsUsed,walkMax
```

在当前程序中，pathsUsed值总是等于WalkMax的值，但如果我们检查如湖泊或建筑物等危险情况时就可能发生变化，这时循环可能在步数到达WalkMax之前结束。

## 10.1.7 联合的声明和使用

==结构的每个域都有一个相对于结构第一个字节的偏移值，但联合的情况有所不同，联合中的所有域都从同一偏移地址开始。联合的大小等于其中最长的域的长度。联合应使用UNION利ENDS伪指令声明。==当联合不是某个结构的成员时，格式如下所示：

```assembly
unionname UNION
union-fields
unionname ENDS
```

如果联合嵌套在结构中，则格式稍有不同：

```assembly
structname STRUCT
	structure-fields
	UNION unionname
		union-fields
	ENDS
structname ENDS
```

==除了所有域只能有一个初始化值这一点之外，联合中域的声明方法与结构中域的声明方法完全相同。==例如，Integer联合为同一数据定义了三种不同的尺寸属性并把所有域都初始化为0了

```assembly
Integer UNION
	D DWORD 0
	W WORD 	0
	B BYTE 	0
Integer ENDS
```

### 保持一致

联合中的域如果使用了初始值，所有域的初始值应保持一致。假设Integer联合声明时各个域使用了不同的初始值：

```assembly
Integer UNION
	D DWORD 1
	W WORD 5
	B BYTE 8
Integer ENDS
```

接下来声明一个名为myInt的Integer变量，使用默认初始值：

```assembly
.data
myInt Integer <>
```

那么myInt.D,myInt.W以及myInt.B都将等于1,汇编器忽略声明中域W和域B的初始值。

### 包含联合的结构

通过在结构声明中使用联合名可把联合嵌套在结构内，如下面FileInfo结构中FileID域的声明：

```assembly
FileInfo STRUCT
	FileID 	 Integer <>
	FileName BYTE 64 DUP(?)
FileInfo ENDS
```

或者，也可以直接在结构内声明联合，如下面对FileID域的声明：

```assembly
FileInfo STRUCT
	UNION FileID
		D DWORD ?
		W WORD  ?
		B BYTE 	?
	ENDS
	FileName BYTE 64 DUP(?)
FileInfo ENDS
```

### 声明和使用联合变量

联合变量的声明和初始化与结构变量大致相同，只有一点重要的区别：
联合只允许一个初始化值。下面是Integer类型的联合变量的例子：

```assembly
vall Integer <12345678h>
val2 Integer <100h>
val3 Integer <>
```

在指令中使用联合时必须提供联合中某个域的名字。下例把寄存器值赋给Integer联合中的域，注意由于可以使用不同大小的操作数而获得的灵活性：

```assembly
mov val3.B,al
mov val3.w,ax
mov val3.D,eax
```

联合中也可以包含结构。下面的INPUT_RECORD结构由一些MS-Windows控制台输入函数使用的，其中包含了一个联合Event。联合Event用于选择一个预定义的结构类型，EventType域用于说明 Event 联合中出现的应该是何种类型的记录。每个结构的组织和大小都是不同的，但每次同一时刻只使用其中的一个结构：

```assembly
INPUT_RECORD STRUCT
	EventType 	WORD ?
	ALIGN 		DWORD
	UNION 		Event
		KEY_EVENT_RECORD <>
		MOUSE_EVENT_RECORD <>
		WINDOW_BUFFER_SIZE_RECORD <>
		MENU_EVENT_RECORD <>
		FOCUS_EVENT_RECORD <>
	ENDS
INPUT_RECORD ENDS
```

Win32 API在命名结构时经常会包含单词RECORD。下面是KEY_EVENT_RECORD结构
的定义：

```assembly
KEY_EVENT_RECORD STRUCT
	bKeyDown		 DWORD 	?
	wRepeatCount 	 WORD	?
	wVirtualKeyCode  WORD 	?
	wVirtualScanCode WORD	?
	UNION uChar
		UnicodeChar WORD	?
		AsciiChar 	BYTE 	?
	ENDS
	dwControlKeyState DWORD ?
KEY_EVENT_RECORD ENDS
```

INPUT_RECORD中其他的STRUCT定义可在SmallWin.inc文件中找到。

# 10.2 宏

## 10.2.1 概述

宏过程(macro procedure)是一个命名的汇编语句块。一旦定义之后，宏过程就可以在程序中被调用任意多次。调用宏过程的时候，宏内的汇编语句块的一份副本被直接插入到程序中调用宏过程的地方。尽管从技术角度来讲宏的使用并不涉及CALL指令，但习惯上我们还是使用“调用”这个术语。
术语“宏过程”是Microsoft宏汇编手册中对那些没有返回值的宏的称呼，具有返回值的宏称为宏函数（macro function)。对于程序员来说，宏（macro)和宏过程（macro procedure一般被理解为是同样的东西。从现在开始，我们将使用更简短的名字：“宏”。

### 声明的位置

==宏可以直接在程序的头部（开始）定义，或者也可以放在单独的文本文件中，通过INCLUDE伪指令把宏定义复制（插入到）到源程序中。宏是在汇编器的预处理阶段(preprocessing step)展开的。在预处理阶段，预处理器读取宏的定义并扫描程序中其余的代码，在调用宏的地方插入宏代码的一份副本。==汇编器在试图汇编任何调用宏的语句前，必须首先找到宏的定义。如果程序定义了宏但没有调用，那么编译后的程序内不会包含宏的代码。
在下面的例子中，名为PrintX的宏包含了一条调用Irvine32或Irvine16库中的WriteChar过
程的语句，其定义一般来说应该放在数据段之前：

```assembly
PrintX MACRO
	mov al,'x'
	call WriteChar
ENDM
```

在代码段中，我们调用了这个宏：

```assembly
code
Printx
```

预处理器扫描程序并发现了对PrintX的调用，于是它就用下面的语句替换对宏的调用：

```assembly
mov al,'X'
call WriteChar
```

其中发生的一切只不过是文本的替换。这个宏好像有点不大灵活，不过后面很快将讲述如何向宏传递参数，这将使得宏非常有用。

## 10.2.2 宏的定义

可以使用MACRO和ENDM伪指令在源程序的任意位置定义宏，定义格式为：

```assembly
macroname MACRO parameter-1, parameter-2...
	statement-list
ENDM
```

宏定义的缩进没有固定的规则，但是建议缩进宏名字（macroname)和ENDM之间的语句。为了保持一致性，可能需要使用特别的前缀字符来命名宏，本书中使用小写的m前缀创建类似于mPutchar,mWriteString和mGotoxy这样易于辨认的宏名字。MACRO和ENDM之间的语句只有在宏被调用的时候才会汇编。宏的定义中可以有任意多的参数，参数之间以逗号分隔。

### 宏的参数

==宏的参数实际上是有名字的容器，以存放调用者传递给宏的文本参数。宏参数实际上可以是整数、变量名或其他值，不过预处理器把各种参数统一视为文本进行处理。宏的参数没有类型，因此预处理器并不检查实参的类型是否与形参的类型匹配。==如果实际上不匹配，那么这类错误在宏展开后由汇编器检查。

#### 例子mPutchar

下面的mPutchar宏接收一个名为char的输入参数，它调用本书链接库中的WriteChar过程在控制台窗口中显示该字符：

```assembly
mPutchar MACRO char
	push 	eax
	mov 	al,char
	call 	WriteChar
	pop 	eax
ENDM
```

## 10.2.3 宏的调用

可以通过把宏的名字插入到程序源代码中调用宏，宏名字后面可以跟必要的参数。调用宏的格式如下：

```assembly
宏名称 参数1,参数2,……
```

宏名称(macroname)必须是在宏被调用的点之前就已经在源代码中定义好了的宏的名字调用宏时的每个实际参数都是一个文本值，该值将替换宏定义中的形式参数，实际参数的顺序必须与宏定义中的形式参数顺序相同，但实际参数的数目不一定非要与宏定义中形式参数的个数完全一致。如果传递的参数个数多于定义中形式参数的个数，汇编器会产生一个警告；如果传递的参数个数少于形式参数的个数，那么未传递的参数为空。

### 调用mPutchar

在上一节中定义了mPutchar宏。在调用mPutchar时可以传递任何字符或字符的ASCII码，下面的语句调用mPutchar宏并传递字母“A”：

```assembly
mPutchar 'A'
```

汇编器的预处理器自动把宏展开成下面的代码：

```assembly
	push eax
1 	mov al,'A'
1 	call writechar
1 	pop eax
```

==左边的“1”表示宏的展开层次，如果在宏内又调用了其他宏的话，该值就会增加。==下面的循环显示字母表中的前20个字母：

```assembly
	mov al,'A'
	mPutchar a1		; macro call
	inc al
	loop L1
```

预处理器把上面循环展开成以下代码（可在列表文件中查看）。在列表文件中，调用宏的语句列在其展开代码之前：

```assembly
	mov 	al,'A'
	mov 	ecx,20
L1:
	mPutcharal	; macro call
1 	push 	eax
1 	mov 	al,al
1	call 	WriteChar
1 	pop 	eax
	inc 	al
	loop 	L1
```

==一般来说，宏代码执行得要比过程代码快，这是由于调用过程代码时有额外的执行CALL和RET指令的开销。不过，使用宏的一个缺点在于：由于每次调用宏时都会在程序中插入宏代码的一份副本，重复使用大量的宏会增大程序的尺寸。==

### 调试包含宏的程序

调试使用宏的程序是一种挑战。在汇编完程序之后，首先检查列表文件（扩展名是.LST)确保宏是按照你的意图展开的。接下来，使用调试器（如Visual Studio.NET)启动程序进行跟踪.这时可以使用显示源码这样的选项（如果调试器支持的话）。在支持源码显示的调试器中，在源码窗口中，宏调用语句后面跟的就是宏展开后生成的代码，下面是一个例子：

```assembly
mwriteAt 	15,10,"Hi there"
push 		edx
mov 		dh, 0Ah
mov 		d1,0Fh
call 		_Gotoxy@0(401551h)
pop 		edx
push 		edx
mov 		edx,offset ??0000(405004h)
call 		_writeString@0(401D64h)
pop 		edx
```

（函数名以下划线开头，是由于Irvine32库使用的是STDCALL调用约定，细节见8.4.1节。）

## 10.2.4 宏的其他特性

### 必须参数

==可以使用REQ修饰符来指定一个宏参数是必须的，如果调用宏的时候没有参数与之匹配，汇编器将显示一条错误信息。==如果一个宏的多个参数都是必需的，那么每个参数都要使用REQ修饰符。在下面的mPutchar宏中，char参数是必须的：

```assembly
mPutchar MACRO char:REQ
	push 	eax
	mov 	al,char
	call 	writechar
	pop 	eax
ENDM
```

### 宏的注释

宏定义内的普通注释行在每次宏展开的时候都会出现。如果不想让注释在宏展开的时候出现，则需在注释前使用双分号：

```assembly
mPutchar MACRO char:REQ
	push 	eax		;;提示：字符只能包含8个数据位
	mov 	al,char
	call 	WriteChar
	pop 	eax
ENDM
```

### ==ECHO伪指令==

在程序被汇编时，ECHO伪指令可以在控制台上显示一条信息。在下面版本的mPutchar中，编译过程中控制台上会显示“Expanding The mPutchar macro”的消息：

```assembly
mPutchar MACRO char:REQ
	ECHO Expanding the mPutchar macro
	push eax
	mov al , char
	call writechar
	pop eax
ENDM
```

### LOCAL伪指令

宏定义中通常会包含标号，并且定义中的代码也会引用这些标号。例如，下面的makeString宏声明了一个名为string的变量，并以一个字符数组初始化：

```assembly
makeString MACRO text
	.data
	string BYTE text,0
ENDM
```

假设调用了该宏两次：

```assembly
makeString "Hello"
makeString "Goodbye"
```

就会产生错误，这是由于汇编器不允许string标号重复定义：

```assembly
	makeString "Hello"
1 	.data
1 	string BYTE "Hello",0
	makeString "Goodbye"
1 	.data
1 	string BYTE "Goodbye",0	; error !
```

### 使用LOCAL

为了避免标号重新定义带来的问题，可以在宏定义内使用LOCAL伪指令处理标号。在标号被标记为LOCAL之后，每次宏展开时预处理器都把标号的名字转换成一个唯一的标识符名。下面是使用了LOCAL的新版本的makeString:

```assembly
makeString MACRO text
	LOCAL string
	.data
	string BYTE text,0
ENDM
```

如果像前面那样调用该宏两次，预处理器就会用一个唯一的标识符替换每次出现的

```assembly
string:
	makeString  "Hello"
1 	.data
1 	??0000 BYTE "Hello",0
	makeString  "Goodbye"
1 	.data
1 	??0001 BYTE "Goodbye",0
```

汇编器生成的标号名的格式是“??nnnn”，其中nnnn是一个唯一的整数。宏内的代码标号也应使用LOCAL伪指令进行处理。

### 包含代码和数据的宏

宏经常既包含代码又包含数据，例如下面的mWrite宏在控制台上显示一个字符串：

```assembly
mwrite MACRO text
	LOCAL string
;; local label
.data
	string BYTE text,0
;; define the string
.code
	push edx
	mov edx , OFFSET string
	call writestring
	pop edx
	ENDM
;下面的语句调用了两次mWrite宏，每次都传递了一个不同的字符串：
mWrite "Please enter your first name"
mwrite "Please enter your last name"
```

编译器对这两条语句的展开显示了每个string标号都被替换成了一个唯一的标号：

```assembly
	mwrite "Please enter your first name"
1	.data
1 		??0000 BYTE "Please enter your first name",0
1	.code
1 		push 	edx
1 		mov 	edx, OFFSET ??0000
1 		call 	Writestring
1 		pop 	edx
	mwrite "Please enter your last name"
1 	.data
1 		??0001 BYTE"Please enter your last name",0
1	.code
1 		push 	edx
1 		mov 	edx,OFFSET ??0001
I 		call 	writestring
1 		pop 	edx
```

### 宏的嵌套

在另外一个宏内被调用的宏称为嵌套宏（nested macro)。汇编器的预处理器遇到对嵌套宏的调用时，就在调用点展开被嵌套的宏。传递给外层宏的参数将直接传递给它的嵌套宏（如果嵌套宏使用了外层宏的参数的话）。
尽量使用模块化的方法来创建宏，保持每个宏的简短，以便用于构造更复杂的宏，这样做有助于减少程序中的重复代码。
例子mWriteLn:如果有一个宏不仅可以向控制台写一串字符，还可以在字符串的末尾添加一个换行符，那该多好啊！下面的mWriteLn就实现了这样的功能，它首先调用mWrite宏，然后又调用了过程Crlf:

```assembly
mwriteLn MACRO text
mwrite 	text
call 	Crlf
ENDM
```

参数text直接传递给了宏mWrite。在程序中可以像下面这样使用该宏：

```assembly
mwriteLn "My Sample Macro Program"
```

在展开的代码中（在列表文件中查看）,语句前面的嵌套层次2表示调用了嵌套宏：

```assembly
	mwriteLn "My Sample Macro Program"
2 	.data
2 		??0002 BYTE "My Sample Macro Program",0
2 	.code
2 		push 	edx
2 		mov 	edx,OFFSET ??0002
2 		call 	Writestring
2 		pop	 	edx
1 		call 	Crlf
```

## 10.2.5使用本书附带的宏库

本书附带的例子程序中有一个小型的但非常有用的宏库（Macro Library),可以在源代码中原有的INCLUDE伪指令之后添加如下的代码行，之后就可以在程序中使用该宏库了：

```assembly
INCLUDE Macros.inc
```

其中的一些宏只对Irvine32和Irvine16库中已有过程的封装，使得传递参数时更简单一些，此外还有一些宏提供了一些新的功能。表10.2详细地描述了库中的每个宏，调用示例代码可以在MacroTest.asm文件中找到。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6g2sabiy8fc0.webp)

### mDumpMem

宏mDumpMem在控制台窗口中显示一块内存的内容。可以向该宏传递一个包含要显示的内存偏移地址的常量、寄存器或变量。第二个参数是要显示的项目的数量，第三个参数是每个项目的大小。（该宏调用了库过程DumpMem,库过程DumpMem要求通过ESI,ECX和EBX传递这三个参数。）假设有如下的数据定义：

```assembly
.data
	array DWORD 1000h,2000h,3000h,4000h
```

下面的语句使用数组的默认属性显示其内容：

```assembly
mDumpMem OFFSET array,LENGTHOF array,TYPE array
```

输出如下：

```assembly
Dump of offset 00405004
00 00 10 00 00 02 00 00 00 00 00 00 00 00
```

下面的语句以字节格式显示了同样的数组：

```assembly
mDumpMem OFFSET array, SIZEOF array, TYPE BYTE
```

输出如下：

```assembly
Dump of offset 00405004
```

下面的代码在堆栈上压入三个值，为ESI,ECX和EBX分别赋了值并使用mDumpMem显示堆栈的内容：

```assembly
mov 	eax,OAAAAAAAA
push 	eax
mov 	eax,OBBBBBBBBh
push 	eax
mov 	eax,OCCCCCCCh
push 	eax
mov 	ebx,1
mov 	ecx,2
mov 	esi,3
mDumpMem esp,8,TYPE DWORD
```

下面的输出结果表明，mDumpMem在堆栈上压入了EBX,ECX和ESI,堆栈中在这三个寄存器值的后面才是在调用mDumpMem前压入堆栈的三个整数：

```assembly
Dump of offset 0012FFAC
00000003 00000002 00000001 CCCCCCC BBBBBBBB AAAAAAAA 7C816D4F
0000001A
```

#### mDumpMem的实现

下面是该宏的代码清单：

```assembly
mDumpMem MACRO address:REQ, itemCount:REQ, componentSize:REQ
; Displays a dump of memory , using the DumpMem procedure
; Receives : memory offset , count of the number of items
; to display , and the size of each memory component .
; Avoid passing EBX , ECX , and ESI as arguments .
	push 	ebx
	push 	ecx
	push 	esi
	mov 	esi,address
	mov 	ecx,itemCount
	mov 	ebx,componentSize
	call 	DumpMem
	pop 	esi
	pop 	ecx
	pop 	ebx
ENDM
```

### mDump

宏mDump以十六进制格式显示变量的地址和内容。向该过程传递一个变量的名字，还可以(可选地）向该变量传递一个字符，指示是否要显示变量的名字。显示格式自动根据变量的尺寸属性（BYTE,WORD或DWORD)确定。下面是两个调用该宏的例子：

```assembly
.data
	diskSize DWORD 12345h
.code
	mDump	diskSize		;无标号
	mDump	diskSize,Y		;显示标号
;代码执行时产生如下输出：
	Dump of offset 00405000
	00012345
	Variable name:diskSize
	Dump of offset 00405000
00012345
```

#### mDump的实现

下面是mDump的清单，mDump实际上调用了mDumpMem,它使用了一
个新的伪指令IFNB(如果不为空）(参见10.3节）检查调用者是否传递了第二个参数：

```assembly
;-------
mDump MACRO varName:REQ,useLabel
; Displays a variable , using its known attributes
; Receives : varName , the name of a variable .
; If useLabel is nonblank , the name of the
; variable is displayed.
	call Crlf
	IFNB <useLabel>
		mwrite"Variable name:&varName"
	ENDIF
	mDumpMem OFFSET varName,LENGTHOF varName,TYPE varName
ENDM
```

&varName中的&是一个替换操作符，使用该操作符的目的是为了允许把varName的实际值插入到字符串常量中。关于&操作符的更多细节请参阅10.3.7节。

### mGotoxy

宏mGotoxy把光标定位在屏幕上指定的行列位置。可以向该宏传递8位的立即数、内存操作数或寄存器：

```assembly
mGotoxy 10,20		;立即数
mGotoxy row,col		;内存操作数
mCotoxy ch,c1		;寄存器值
```

#### mGotoxy的实现

下面是该宏的源码清单。

```assembly
mCotoxy MACRO X:REQ,Y:REQ
; Sets the cursor position in the console window.
; Receives : X and Y coordinates ( type BYTE ) . Avoid
; passing DH and DL as arguments.
	push edx
	mov dh,Y
	mov dl,X
	call Gotoxy
	pop edx
ENDM
```

#### 避免寄存器冲突

宏的参数是寄存器时，有可能与宏内部使用的寄存器冲突。例如，如果使用DH和DL调用mGotoxy,生成的代码将不正确。为了查看为什么如此，检查一下参数被替换后展开的代码：

```assembly
1 push 	edx
2 mov 	dh,dl	;;行
3 mov	 dl,dh	;;列
4 call 	Gotoxy
5 pop 	edx
```

假如DL被用于传递Y而DH被用于传递X,在第二行中DH的值就已经被覆盖掉了，这时我们再没有机会在第三行中把它赋给DL了。
无论何时，只要有可能，在宏定义的时候应该指明哪些寄存器不能用作宏的参数。

### mReadString

宏mReadString从键盘上读取一个字符串并把该字符串存储在一个缓冲区中。在内部，宏调用了库过程ReadString,应该向该过程传递一个缓冲区的名字：

```assembly
.data
	firstName BYTE 30 DUP(?)
.code
	mReadstr firstName
```

下面是宏的源码清单：

```assembly
mReadString MACRO varName:REQ
; Reads from standard input into a buffer .
; Receives : the name of the buffer . Avoid passing
; ECX and EDX as arguments .
	push 	ecx
	push 	edx
	mov 	edx,OFFSET varName
	mov 	ecx,SIZEOF varName
	call 	ReadString
	pop 	edx
	pop 	ecx
ENDM
```

### mShow

宏mShow以调用者选定的格式显示任意寄存器或变量的名字及内容。应该向该宏传递寄存器的名字，后跟一系列字符指明期望的输出格式。格式代码如下：H=十六进制，D=无符号十进制整数，I=有符号十进制整数，B=二进制，N=添加一个换行符。可以组合多种输出格式，也可以指定多个换行符。默认格式是“HIN”。mShow在调试时是很有帮助的，库过程DumpRegs中就大量使用了该宏。可以在任何程序中插入对mShow的调用，以显示重要的寄存器或变量的内容。
例子：下面的语句以十六进制、无符号整数、有符号整数以及二进制格式显示AX寄存器的内容：

```assembly
mov 	ax,4096
mShow 	AX		;默认选项：HIN
mShow 	AX,DBN	;无符号十进制整数、二进制、换行符
```

下面是输出：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.1bvj3goaii3k.webp)

例子：下面的语句在同一行上以无符号十进制整数格式显示AX,BX,CX和DX的内容：

```assembly
;插入一些测试值并显示4个寄存器
mov 	ax,1
mov 	bx,2
mov 	cx,3
mov 	dx,4
mShow 	AX,D
mShow 	BX,D
mShow 	CX,D
mShow 	DX,DN
```

下面是对应的输出：

```assembly
AX=1d BX=2d CX=3d DX=4d
```

例子：下面调用mShow以无符号整数格式显示mydword的内容：

```assembly
.data
	mydword DWORD ?
.code
	mShow mydword,DN
```

mShow的实现：mShow的实现代码过长，这里就不再给出其具体的实现代码了，读者可以在Macros.inc文件中找到相应的代码。在实现mShow时必须格外小心，以确保在宏本身内的代码修改相应的寄存器之前显示该寄存器的内容。

### mShowRegister

宏mShowRegister以十六进制格式显示一个32位寄存器的内容。应该向该宏传递要为该寄存器显示的名字，后面跟真正要显示的寄存器名。下面的宏调用指定要显示的寄存器名字是EBX:

```assembly
mShowRegister EBX,ebx
```

产生的输出如下：

```assembly
EBX=7FFD9000
```

下面的调用使用尖括号括起了第一个参数字符串，这是由于它中间包含了一个空格：

```assembly
mShowRegister <Stack Pointer>, esp
```

产生的输出如下：

```assembly
Stack Pointer=0012FFCO
```

#### mShowRegister的实现：

下面是宏的源码。

```assembly
mShowRegister MACRO regName,regValue
			LOCAL tempStr
; Displays a register's name and contents .
; Receives : the register name , the register value .
.data
	tempStr BYTE " &regName=",0
.code
	push 	eax		
; Display the register name
	push 	edx
	mov 	edx, OFFSET tempStr
	call 	WriteString
	pop 	edx
;Display the register contents
	mov 	eax , regValue
	call 	writeHex
	pop 	eax
ENDM
```

### mWriteSpace

宏mWriteSpace在控制台窗口中显示一个或多个空格，可以向该宏传递一个数字指定要显示的空格的数量（默认是1)。例如，下面的语句将显示5个空格：

```assembly
mwriteSpace 5
```

mWriteSpace的实现：下面是mWriteSpace的源码。

```assembly
mwriteSpace MACRO count:=<1>
; Writes one or more spaces to the console window .
; Receives : an integer specifying the number of spaces .
; Default value of count is 1.
		LOCAL spaces
.data
	spaces BYTE count DUP(''),0
.code
	push 	edx
	mov 	edx,OFFSET spaces
	call 	WriteString
	pop 	edx
ENDM
```

10.3.2节讲述了宏的参数如何使用默认的初始化值。

### mWriteString

宏mWriteString在控制台窗口中显示一个字符串的内容。该宏简化了对WriteString过程的调用，允许在宏的同一行上传递字符串变量的名字。例如：

```assembly
.data
	str1 BYTE "Please enter your name:",0
.code
	mWriteString str1
```

#### mWriteString的实现

下面mWriteString的实现在堆栈上保存EDX的值，然后通过EDX保存字符串的偏移地址，最后在过程调用后再从堆栈中弹出保存的EDX的值：

```assembly
mWriteString MACRO buffer:REQ
; Writes a string variable to standard output .
; Receives : string variable name .
	push 	edx
	mov 	edx, OFFSET buffer
	call 	WriteString
	pop 	edx
ENDM
```

## 10.2.6 例子程序：封装

下面写一个小程序（Wraps.asm)来演示前面那些对过程进行了封装的宏，由于每个宏都隐藏了大量单调乏味的参数传递步骤，所以程序出奇地紧凑。到现在为止，所介绍的所有宏都在Macros.inc文件中定义：

```assembly
TITLE Procedure Wrapper Macros	(Wraps.asm)
; This program demonstrates macros as wrappers
; for library procedures. Contents: mGotoxy, mWrite,
; mWriteString, mReadString, and mDumpMem.
INCLUDE Irvine32.inc
INCLUDE Macros.inc
;宏定义
.data
	array 		DWORD 1,2,3,4,5,6,7,8
	firstName 	BYTE 31 DUP(?)
	lastName 	BYTE 31 DUP(?)
.code
main PROC
	mGotoxy 0,0
	mWrite <"Sample Macro Program",Odh,Oah>	;输入用户名
	mCotoxy 0,5
	mWrite	"Please enter your first name:"
	mReadString firstName
	call Crlf
	mwrite	"Please enter your last name:"
	mReadString lastName
	call Crlf	;显示用户名
	mwrite 	"Your name is"
	mWriteString firstName
	mwriteSpace
	mWriteString lastName
	call crlf		;显示数组中的整数
	mDumpMem OFFSET array, LENCTHOF array, TYPE array
	exit
	main ENDP
END main
```

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.3kditu3hf4o0.webp)

# 10.3 条件汇编伪指令

条件汇编伪指令和宏联合使用可以使得宏更加灵活，条件汇编伪指令的一般格式是：

```assembly
IF condition
	statements
[ELSE
	statements]
ENDIF
```

本章介绍的常量条件伪指令和6.7节介绍的运行时伪指令（如.IF和.ENDIF)是不一样的，读者不要混淆这二者，运行时伪指令（如.IF)是基于存储在寄存器或变量中的运行时值对表达式求值的。
表10.3列出了一些常用的条件汇编伪指令，当说明中提到一条伪指令“允许汇编”的时候，就意味着其后直到下一个相邻的ELSE或ENDIF伪指令之间的所有语句都会被编译，这里必须强调的是，表中列出的伪指令是在编译时而不是在运行时求值的。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.3br9grxlkw00.webp)

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.swhhemb12k0.webp)

## 10.3.1 检查缺少的参数

宏可以检查其任何一个参数是否为空。通常，如果一个宏接收了空参数，预处理器展开宏的时候就会导致生成无效指令。例如，如果调用宏mWriteString的时候不传递参数，在宏展开的日候，把字符串偏移送EDX的指令就成了无效指令。下面是编译器生成的语句，汇编器检测到了缺少参数的情况并产生一条错误信息：

```assembly
mwritestr
1 push edx
1 mov edx,OFFSET
Macro2 .asm(18):error A2081 : missing operand after unary operator
1 call writestring
1 pop edx
```

==为防止缺少参数产生的错误，可使用IFB(if blank)伪指令，该伪指令在宏参数为空时返回真；也可以使用IFNB(if not blank)伪指令，它在宏参数非空时返回真。==下面我们来编写一个亲的mWriteString宏，该宏在汇编过程中如果缺少参数就显示一条错误信息：

```assembly
mwritestr MACRO string
IFB <string>
	ECHO --------------
	ECHO * Error: parameter missing in mwritestr
	ECHO * (no code generated)
	ECHO --------------
	EXITM
ENDIF
	push 	edx
	mov 	edx,OFFSET string
	call	writestring
	pop 	edx
ENDM
```

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.3mh55te1t660.webp)

## 10.3.2 默认的参数初始化值

==宏可以有默认的参数初始化值。如果调用宏时缺少参数，则使用默认参数。==格式如下所示：

```assembly
paramname:=<argument>
```

(操作符前后的空格不是必需的)例如，mWriteLn宏可提供一个包含一个空格的字符串作为默认参数，如果调用时不带参数，那么仍然会打印一个空格并在后面跟一个换行符：

```assembly
mWriteLn MACRO text:=<" ">
	mwrite 	text
	call 	Crlf
ENDM
```

如果使用空字符串(")作为默认的宏参数，那么编译器会产生一个错误提示，所以至少要在两个引号之间插入一个空格。

## 10.3.3 布尔表达式

汇编器允许在IF和其他条件伪指令中包含的常量布尔表达式中使用下面的关系运算符：

```assembly
LT	小于
GT	大于
EQ	等于
NE	不等于
LE	小于等于
GE	大于等于
```

## 10.3.4 IF,ELSE和ENDIF伪指令

IF伪指令后面必须跟一个常量布尔表达式。表达式可包含整数常量、符号常量或宏参数常量，但是不能包含寄存器或变量名。其中的一种格式是只使用IF和ENDIF:

```assembly
IF expression
	statement-list
ENDIF
```

另一种格式是使用IF,ELSE和ENDIF:

```assembly
IF expression
	statement-list
ELSE
	statement-list
ENDIF
```

#### 例子

mGotoxyConst宏。mGotoxyConst宏使用LT和GT操作符对传递给宏的参数进行范围检查，参数X和Y必须是常量。另一个符号常量ERRS用于统计发现的错误数，检查X参数的时候，ERRS可能被设置为1;检查Y参数的时候，可能会再对ERRS加1,最后如果ERRS的值大于0,那么使用EXITM伪指令来退出宏：

```assembly
mCotoxyConst MACRO X:REQ,Y:REQ
;Sets the cursor position at column X , row Y .
;Requires X and Y coordinates to be constant expressions
;in the ranges 0 < = X < 80 and 0 < = Y < 24 .
-------
	LOCAL ERRS		;;局部常量
	ERRS = 0
	IF (X LT 0) OR (X GT 79)
		ECHO Warning : First argument to mGotoxy ( X ) is out of range .
		ECHO ********
		ERRS = 1
	ENDIF
	IF (Y LT 0) OR (Y CT 24)
		ECHO Warning : Second argument to mGotoxy ( Y ) is out of range
		ECHO ★★★★
		ERRS = ERRS + 1
	ENDIF
IF ERRS GT 0		;;如果发现了错误
	EXITM			;;退出宏
ENDIF
	push 	edx
	mov 	dh,Y
	mov 	dl,X
	call 	Gotoxy
	pop 	edx
ENDM
```

## 10.3.5 IFIDN和IFIDNI伪指令

==IFIDNI伪指令以大小写不敏感的方式比较两个符号（包括宏参数）是否相等，如果相等的话则返回TRUE。IFIDN伪指令也比较两个符号是否相等，但是要区分大小写。==当要确保调用宏时传递的宏参数不和宏内使用的寄存器冲突时，IFIDNI是很有用的，它的使用格式如下：

```assembly
IFIDNI <symbol>, <symbol>
	statements
ENDIF
```

IFIDN的格式与IFIDNI的格式相同。
在下面的mReadBuf宏中，第二个参数不能是EDX,因为buffer的偏移被送到EDX的时候，参数就会被覆盖。在下面修改后的版本中，如果不满足这个条件就显示一条错误信息：

```assembly
mReadBuf MACRO bufferPtr, maxChars
; Reads from the keyboard into a buffer .
; Receives : offset of the buffer , count of the maximum
; number of characters that can be entered. The
; second argument cannot be edx or EDX
	IFIDNI <maxChars>, <EDX>
		ECHO Warning: Second argument to mReadBuf cannot be EDX
		ECHO *****
		EXITM
	ENDIF
	push 	ecx
	push 	edx
	mov	 	edx,bufferptr
	mov 	ecx,maxChars
	call 	ReadString
	pop 	edx
	pop 	ecx
ENDM
```

下面的语句中由于第二个参数是EDX,所以将导致该宏产生一条错误信息：

```assembly
mReadBuf OFFSET buffer,edx
```

## 10.3.6 例子：对矩阵行求和

在9.4.2节已经介绍了如何对一个字节矩阵的一行求和，第9章的一道编程练习要求读者对这个过程进一步一般化，以处理字矩阵和双字矩阵。习题的解答可能有点允长，下面我们看看是否可以使用宏来简化这个任务。下面是第9章给出的原始的calc_row_sum过程：

```assembly
calc_row_sum PROC USES ebx ecx esi
; Calculates the sum of a row in a byte matrix .
; Receives : EBX = table offset , EAX = row index ,
; ECX = row size,in bytes.
; Returns : EAX holds the sum .
	mul ecx			; row index * row size
	add ebx,eax		;行的偏移地址
	mov eax,0		;累加器
	mov esi,0		;列的索引
L1:
	movzx 	edx,BYTE PTR[ebx+esi];取一个字节
	add 	eax,edx		;累加
	inc		esi			;行的下一个字节
	loop 	L1
	ret
calc_row_sum ENDP
```

首先，把PROC换成MACRO,删除RET指令，把ENDP换成ENDM,插入等价的PUSH
和POP指令替换USES操作符：

```assembly
mCalc_row_sum MACRO
	push 	ebx		;保存要修改的寄存器
	push 	ecx
	push 	esi
	mul 	ecx			; row index * row size
	add 	ebx,eax		;行的偏移地址
	mov 	eax,0		;累加器
	mov 	esi,0		;列的索引
L1:
	movzx 	edx,BYTE PTR[ebx+esi]	;取一个字节
	add 	eax,edx					;累加
	inc		esi						;行的下一个字节
	loop 	L1
	pop 	esi						;恢复修改的寄存器
	pop 	ecx
	pop 	ebx
ENDM
```

接下来，使用宏参数替换寄存器参数并在宏内初始化寄存器参数：

```assembly
mCalc_row_sum MACRO index,arrayoffset,rowSize
	push ebx		;保存要修改的寄存器
	push ecx
	push esi		;设置要求的寄存器参数
	mov eax,index
	mov ebx,arrayoffset
	mov ecx,rowSize
	mul ecx			; row index * row size
	add ebx,eax		;行的偏移地址
	mov eax,0		;累加器
	mov esi,0		;列的索引
L1: 
	movzx edx,BYTE PTR[ebx + esi]	;取一个字节
	add eax,edx		;累加
	inc	esi			;行的下一个字节
	loop L1
	pop esi			;恢复修改的寄存器
	pop ecx
	pop ebx
ENDM
```

我们增加一个参数eltType,指定数组的类型（BYTE,WORD或DWORD):

```assembly
mCalc_row_sum MACRO index,arrayoffset,rowSize,eltType
```

要复制到ECX中的rowSize参数现在表示的是每行的字节数，如果要以ECX作为循环计数器，它就必须包含每行的元素的数目。因此，对于16位的数组，把ECX除以2;对于双字数组，把ECX除以4。一种快速方法是以eltType/2为计数器对ECX进行右移位操作：

```assembly
shr ecx, (TYPE eltType/2)	;byte=0,word=1,dword=2
```

我们在MOVZX指令的基址变址操作数中以TYPE eltType为比例因子：

```assembly
movzx edx,eltType PTR [ ebx + esi * ( TYPE eltType ) ]
```

不过如果右边的源操作数是双字类型，MOVZX无法汇编，因此必须在eltType等于DWORD的时候使用IFIDNI操作符单独创建一条MOV指令：

```assembly
IFIDNI <eltType>, <DWORD>
	mov edx,eltType PTR[ebx+esi*(TYPE eltType)]
ELSE
	movzx edx,eltType PTR[ebx+esi*(TYPE e1tType)]
ENDIF
```

最后得到了修改完成后的宏，一定要记得把标号L1修改为宏内的LOCAL标号：

```assembly
mCalc_row_sum MACRO index,arrayoffset,rowSize,eltType
; Calculates the sum of a row in a two-dimensional array .
; Receives : row index , offset of the array , number of bytes
; in each table row , and the array type ( BYTE , WORD , or DWORD )
; Returns : EAX = sum .
	LOCAL L1
;保存要修改的寄存器
	push ebx		
	push ecx
	push esi		
;设置要求的寄存器参数
	mov eax,index
	mov ebx,arrayoffset
	mov ecx,rowSize
;计算行的偏移地址
	mul ecx			; row index * row size
	add ebx,eax		;行的偏移地址
;准备循环计数器
	shr ecx, (TYPE eltType / 2) ; byte=0, word=1, dword=2
;初始化累加器和列索引
	mov eax,0		;累加器
	mov esi,0		;列的索引
L1:
	IFIDNI <eltType>, <DWORD>
		mov edx,eltType PTR[ebx+esi*(TYPE eltType)]
	ELSE
		movzx edx,eltType PTR[ebx+esi*(TYPE eltType)]
	ENDIF
	add eax,edx		;取一个字节
	inc	esi
	loop L1
	pop esi			;恢复修改的寄存器
	pop ecx
	pop ebx
ENDM
```

下面是对该宏的调用示例，示例中使用了字节数组、字数组和双字数组，参见rowsum.asm程序：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.1chl3ygvwu1s.webp)

## 10.3.7 特殊操作符

有4个特殊的汇编操作符可使宏的使用更加灵活：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.76tkejem4gg0.webp)

### 替换操作符(&)

==替换操作符(&)将宏内部对宏参数的引用替换为调用时的实际值，这在对宏参数的引用可能有歧义的情况下是特别有用的。==例如mShowRegister宏（10.2.5节）显示32位寄存器的名称及其内容（以十六进制值显示）,下面是调用示例：

```assembly
.code
mShowRegister ECX
```

下面是调用该宏产生的输出：

```assembly
ECX = 00000101
```

在宏的内部可以定义一个包含寄存器名的字符串变量：

```assembly
mShowRegister MACRO regName
.data
tempStr BYTE "regName=",0
```

但预处理器会认为regName是字符串的一部分，并不会用传递给宏的实际参数替换它。如果我们在它前面加一个&操作符，就会强制预处理器在字符串中插入实际传递的宏参数（例如ECX)下面演示了如何正确地定义tempStr:

```assembly
mShowRegister MACRO regName
.data
tempStr BYTE " &regName=",0
```

### 展开操作符(%)

==展开操作符(%)展开文本宏或把常量表达式转换成文本表示形式。==这有几种情况，在TEXTEQU联合使用时，%操作符对常量表达式求值并把结果转换成整数。在下例中，%操作符对表达式(5+count)求值并返回整数15(作为文本）:

```assembly
count = 10
sumVal TEXTEQU % (5 + count) ;="15"
```

如果宏要求使用整数常量参数，%操作符允许灵活地传递整数表达式。表达式首先被计算求值得出整数值结果，然后再传递给宏。例如下例中调用mGotoxyConst宏时，其参数中的两个表达式分别被求值为50和7:

```assembly
mGotoxyConst % (5*10), %(3+4)
```

预处理器将生成下面的语句：

```assembly
1 push edx
I mov dh, 7
```

#### 行首的%

==当展开操作符（%)作为源代码行的第一个字符的时候，就指示预处理器展开在行发现的所有文本宏和宏函数。==例如，假设在汇编过程中要在屏幕上显示数组的大小，下面的语句并不会得到期望的结果：

```assembly
.data
	array DWORD 1,2,3,4,5,6,7,8
.code
	ECHO The array contains (SIZEOF array) bytes
	ECHO The array contains (SIZEOF array) bytes
```

屏幕上的输出毫无用处：

```assembly
The array contains (STZEOF array) bytes
The array contains % ( SIZEOF array ) bytes
```

如果使用TEXTEQU创建一个包含（SIZEOF array)的文本宏，就可以在下一行中使用%操作符来将其展开：

```assembly
TempStr TEXTEQU % (SIZEOF array)
% ECHO The array contains TempStr bytes
```

产生的输出如下：

```
The array contains 32 bytes
```

#### 显示行号

下面的Mu132宏把前两个参数相乘并在第三个参数中返回乘积，该宏的参数可以是寄存器、内存操作数甚至是立即操作数（除了第三个参数之外）:

```assembly
MUL32 MACRO op1 , op2 , product
	IFIDNI <op2>,<EAX>
		ECHO -------------------
		LINENUM TEXTEQU % (@LINE)
	%	ECHO * Error on line LINENUM: EAX cannot be the second
		ECHO * argument when invoking the MUL32 macro.
		ECHO -------------------
EXITM
ENDIF
	push 	eax
	mov 	eax,op1
	mul 	op2
	mov 	product,eax
	pop 	eax
ENDM
```

Mul32宏要求第二个操作数不能是EAX。有趣的是，这个宏显示了调用宏的语句所在的行号，以利于跟踪并修正问题。在这个宏里首先定义了文本宏LINENUM,它引用了@LINE汇编操作符该操作符用于返回当前源码行的行号：

```assembly
LINENUM TEXTEQU %(@LINE)
```

接下来在包含ECHO语句的行中，行首定义的展开操作符（%)导致LINENUM被展开：

```assembly
ECHO* Error on line LINENUM: EAX cannot be the second
```

假设下面的宏调用发生在程序的第40行：

```assembly
MUL32 vall,eax,va13
```

在汇编过程中会显示以下信息：
```assembly
Error on line 40: EAX cannot be the second
argument when invoking the MUL32 macro.
```

读者可以在Macro3.asm文件中查看测试Mul32宏的代码。

### 文本操作符（<>)

==文本操作符(<>)允许把多个字符或符号作为一个字符串整体进行传递，以阻止预处理器把尖括号内的参数解释为单独的参数。==该操作符在字符串包含逗号、百分号、连接符或分号的时候特别有用。如果不使用该操作符，这些字符就会被解释成分隔符或其他操作符。例如，本章前面给出的宏mWrite只接收一个唯一的字符串参数，如果传递下面的字符串，预处理器会将其解释为三个独立的参数：

```assembly
mwrite "Line three", odh, Oah
```

由于该宏只接收一个参数，所以第一个逗号后面的所有参数都将被忽略，如果把字符串用文本操作符括起来，预处理器就会把尖括号内所有文本作为一个宏参数进行传递：

```assembly
mwrite <"Line three", odh, 0ah>
```



### 特殊文本字符操作符(!)

==特殊文本字符操作符(!)的目的和文本操作符的目的几乎是一样的：强制预处理器把预定义的操作符字符作为普通的字符。==在下面的TEXTEQU定义中，操作符阻止了预处理器把“&gt;”符号解释为文本分隔符：

```
BadYValue TEXTEQU <Warning: Y-coordinate is !> 24>
```

#### 警告消息的例子：

下面的例子有助于说明%、&和！操作符是如何一起使用的。假设前面已经定义了BadYValue,下面创建的ShowWarning宏接收一个文本参数，把该文本参数用引号括起来并传递给mWrite宏，注意替换操作符（&)的用法：

```assembly
Showwarning MACRO message
	mWrite " &message "
ENDM
```

接下来我们调用ShowWarning,把表达式%BadYValue传递给它，%操作符对BadYValue求
值并产生等价的字符串：

```assembly
.code
	Showwarning %BadYValue
```

可能与预期的一样，程序运行并显示下面的警告信息：

```assembly
Warning: Y-coordinate is >24
```

## 10.3.8 宏函数

宏函数与宏过程相似，它们都为一个汇编语句块赋予了一个名字，所不同的是，宏函数总是用EXITM伪指令返回一个常量（整数或字符串）。==在下面的例子中，如果符号已定义则IsDefined宏返回真（-1),否则返回假（0):==

```assembly
IsDefined MACRO symbol
	IFDEF symbol
		EXITM <-1>		;;真
	ELSE
		EXITM <0>		;;假
	ENDIF
ENDM
```

EXITM(退出宏）指令停止了宏的进一步展开。

#### 调用宏函数

调用宏函数时参数列表必须用圆括号括起来。例如，我们可以调用IsDefined宏，
并向它传递一个已经或尚未定义的参数RealMode:

```assembly
IF IsDefined(RealMode)
	mov ax,@data
	mov ds,ax
ENDIF
```

如果编译器在编译该语句之前已经遇到了RealMode的定义，则编译下面两条语句：

```assembly
mov ax,@data
mov ds,ax
```

同样的IF指令块也可以放在宏Startup内：

```assembly
Startup MACRO
	IF IsDefined(RealMode)
		mov ax,@data
		mov ds,ax
	ENDIF
ENDM
```

像IsDefined这样的宏在设计那些要在多种不同的内存模式下汇编的程序时是非常有用的。例如可以用IsDefined来决定要包含哪个文件：

```assembly
IF IsDefined(RealMode)
	INCLUDE Irvine16.inc
ELSE
	INCLUDE Irvine32.inc
ENDIF
```

#### 定义RealMode符号

剩下的所有事情就是寻找一种定义RealMode符号的方法了。一种方法是在程序开始放上下面的语句：

```assembly
RealMode = 1
```

此外，还可以使用编译器的命令行选项“-D”来定义符号，下面的ML命令行定义了RealMode符号并为其赋值1:

```assembly
ML-C-DRea1Mode=1 myProg.asm
```

相应地，编译保护模式程序的ML命令行不应该定义RealMode符号：

```assembly
ML-C myProg.asm
```

#### HelloNew程序

下面的程序（HelloNew.asm)使用了前面给出的宏在屏幕上显示一条消息：

```assembly
TITLE Macro Functions
(HelloNew.asm)
INCLUDE Macros . inc
IF IsDefined(RealMode)
	INCLUDE Irvine16.inc
ELSE
	INCLUDE Irvine32.inc
ENDIF
.code
main PROC
	Startup
	mWrite <"This program can be assembled to run",0dh,0ah>
	mWrite <"in both Real mode and Protected mode.",0dh,0ah>
	exit
main ENDP
END main
```

程序既可在实地址模式下编译，也可以在保护模式下编译。

# 10.4 定义重复块

MASM中有一些用于生成重复语句块的循环伪指令：WHILE,REPEAT,FOR和FORC。与LOOP指令不同，这些伪指令只能用汇编期间，而且只能使用常量值作为循环条件和计数器：

- ==WHILE伪指令根据一个布尔表达式来重复语句块。==
- ==REPEAT伪指令根据一个计数器来重复语句块。==
- ==FOR伪指令通过遍历一个符号列表中的每个符号来重复语句块。==
- ==FORC伪指令通过遍历一个字符串中的每个字符来重复语句块。==

在例子程序Repeat.asm中有每个伪指令的解释说明。

## 10.4.1 WHILE伪指令

==只要特定的常量表达式为真，WHILE伪指令就重复语句块。==格式如下：

```assembly
WHILE constExpression
	statements
ENDM
```

==下面的代码显示了如何生成1到F0000000h之间的斐波那契数作为一系列编译时期的常量==：

```assembly
.data
	val1 = 1
	val2 = 1
	DWORD vall		;前两个值
	DWORD val2
	val3 = vall + val2
WHILE val3 LT 0F0000000h
	DWORD val3
	vall = val2
	val2 = val3
	val3 = val1 + val2
ENDM
```

代码生成的常量值可在列表文件中（.LST)查看。

## 10.4.2 REPEAT 伪指令

==REPEAT伪指令以固定次数重复指令块。==格式如下：

```assembly
REPEAT constExpression
	statements
ENDM
```

==constExpression是一个无符号整数常量表达式，它决定了重复的次数。==REPEAT伪指令可以像DUP伪指令一样用于定义数组。在下例中，结构WeatherReadings包含了一个地理位置字符串后面跟一个降雨量（rainfall)和湿度（humidity)的数组：

```assembly
WEEKS_PER_YEAR = 52
WeatherReadings STRUCT
	location BYTE 50 DUP(0)
	REPEAT WEEKS_PER_YEAR
		LOCAL rainfall,humidity
		rainfall DWORD
		ENnumidity DWORD
WeatherReadings ENDS
```

其中的LOCAL伪指令用于避免在汇编时循环重复定义rainfall和humidity可能导致的重复定义错误。

## 10.4.3 FOR伪指令

==FOR伪指令通过遍历一个以逗号分隔的符号列表重复语句块，符号列表中的每个符号都引发一次循环。==格式如下所示：

```assembly
FOR parameter, <arg1, arg2, arg3,...>
	statements
ENDM
```

在第一次循环时，参数(parameter)的取值为arg1,第二次循环时，参数的取值为arg2,如此反复，直到遍历完列表中的最后一个符号为止。

#### 学生注册的例子

现在我们来创建一个学生注册登记的方案，其中使用COURSE结构来代表课程，COURSE结构中包含课程编号和学分数。另外使用SEMESTER结构表示一个学季，其中包含了6个课程结构的数组和一个名为NumCourses的计数器：

```assembly
COURSE STRUCT
	Number 	BYTE 9 DUP(?)
	Credits BYTE	?
COURSE ENDS
;A semester contains an array of courses.
SEMESTER STRUCT
	Courses 	COURSE 6 DUP(<>)
	NumCourses  WORD ?
SEMESTER ENDS
```

我们可以使用FOR循环定义4个SEMESTER对象，每个对象都有一个从尖括号中的符号列表中选出的不同名字：

```assembly
.data
	FOR semName,<Fa111999, Spring2000, Summer2000, Fal12000>
	semName SEMESTER <>
ENDM
```

如果查看列表文件，就会发现如下的变量定义：

```assembly
.data
	Fa111999 	SEMESTER <>
	Spring2000 	SEMESTER <>
	Summer2000 	SEMESTER <>
	Fa112000 	SEMESTER <>
```

## 10.4.4 FORC伪指令

==FORC伪指令通过遍历一个字符串中的每个字符来重复语句块，字符串中的每个字符都引发一次循环，==格式如下：

```assembly
FORC parameter, <string>
	statements
ENDM
```

第一次循环开始时，参数(parameter)等于字符串中的第一个字符；第二次循环时，参数等于字符串中的第二个字符。依次类推，直到字符串结束。下例创建了一个字符查找列表，表中包含了几个非字母字符。注意<和>前面必须加特殊文本字符操作符(!),以防止与FORC伪指令的格式参数冲突：

```assembly
Delimiters LABEL BYTE
	FORC code,<@#$8&*!<!>>
	BYTE "&code"
ENDM
```

在列表文件中可以看到，该代码生成了下面的数据：

```
00000000 40 1 BYTE "@"
00000001 23 1 BYTE "#"
00000002 24 1 BYTE "$"
00000003 25 1 BYTE "%"
00000004 5E 1 BYTE "A"
00000005 26 1 BYTE "&"
00000006 2A 1 BYTE "*"
00000007 3C 1 BYTE "<"
00000008 3E 1 BYTE ">"
```

## 10.4.5 例子：链表

组合使用结构声明和REPEAT伪指令以使汇编器生成一个链表（Linked List)数据结构是相当简单的，==链表中的每个节点包含一个数据（data)区和一个链接（link)区：==

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6nnc0zzax8o0.webp)

==在每个节点的数据区内可以使用一个或多个变量存放节点的数据。在链接区中，用一个指针存放链表中下一个相邻节点的地址，最后一个节点的链接区通常包含一个空指针。==下面编写一个创建和显示简单链表的程序。程序首先定义一个链表节点结构，里面包含一个整数（数据区）和一个指向下一个相邻节点的指针：

```assembly
ListNode STRUC
	NodeData 	DWORD	?		;节点的数据
	NextPtr 	DWORD	?		;下一个节点的指针
ListNode ENDS
```

接下来使用REPEAT伪指令创建ListNode对象的多个实例。为了测试的目的，NodeData域中包含了一个取值1~15的整数常量。在循环内部，我们增加计数器的值并把计数器的值插入到ListNode的各个域中：

```assembly
TotalNodeCount = 15
NULL = 0
Counter = 0
.data
LinkedList LABEL PTR ListNode
REPEAT Total NodeCount
	Counter = Counter + 1
	ListNode <Counter,($+Counter*SIZEOF ListNode)>
ENDM
```

表达式(\$+Counter*SIZEOF ListNode)告诉编译器把当前计数器和ListNode的大小相乘并把乘积与当前地址计数器相加，然后再把结果插入到ListNode结构的NextPtr域中。注意：地址指针值中的（\$)总是固定为第一个节点的地址值，这很有趣。链表使用一个尾节点标记链表的结束，尾节点的NextPtr域为0:

```assembly
ListNode <0,0>
```

在程序遍历链表的时候，使用下面的语句获取NextPtr的值并同NULL相比较，以检查是否到达了链表的结尾：

```assembly
mov eax,(ListNode PTR [esi]).NextPtr
cmp eax,NULL
```

### 程序清单

下面是程序的完整清单。在main过程中，程序使用循环遍历链表并显示所有节点的数据值，循环中没有使用固定的计数器，相反，程序通过检查NULL指针来判断是否到达了链表尾部，如果发现NULL指针则终止循环：

```assembly
TITLE Creating a Linked List	(List.asm)
INCLUDE Irvine32.inc
ListNode STRUCT
	NodeData 	DWORD ?
	NextPtr 	DWORD ?
ListNode ENDS
TotalNodeCount = 15
NULL = 0
Counter = 0
.data
LinkedList LABEL PTR ListNode
REPEAT TotalNodeCount
	Counter = Counter+1
	ListNode <Counter,($+Counter*SIZEOF ListNode)>
ENDM
ListNode <0,0>	;尾节点
.code
main PROC
	mov esi,OFFSET LinkedList	;显示NodeData域中的整数
NextNode:
;检查是否是尾节点
	mov eax,(ListNode PTR [esi]).NextPtr
	cmp eax,NULL
	je 	quit
;显示节点数据
	mov eax,(ListNode PTR[esi]).NodeData
	call WriteDec
	call Crlf
;获取下一个节点的指针
	mov esi,(ListNode PTR [esi]).NextPtr
	jmp NextNode
quit:
	exit
	main ENDP
END main
```

# 10.5 本章小结

==结构是在定义用户自定义类型时使用的模板或模式。MS-Windows的API库中已经预定义很多结构，并用它们在应用程序和库之间传递数据。结构可以包含多种类型的域，每个域声明都可以使用域初始值，域初始值给了结构域一个默认值。==
结构本身并不占用存储空间，但结构变量占用存储空间，SIZEOF操作符返回变量使用的字节数。
使用结构变量或类似于[esi]的间接操作数加上点操作符可以引用结构的域，在使用间接操数来引用结构的域时，必须使用PTR操作符来标识结构的类型，如（COORD PTR[esi]).X
结构中还可以包含结构域。Drunkard's Walk(醉汉走路）程序中（10.1.6节）演示了这样的例子，其中的DrunkardWalk结构中又包含了COORD结构。
==宏通常在程序的开始部分定义，位于数据段和代码段之前。在后面调用宏时，预处理器就在调用宏的地方插入宏包含的代码块的一份副本。==
可用宏把过程调用封装起来，以简化参数传递以及在栈上保存寄存器等工作。宏mGotoxy,nDumpMem和mWriteString调用了本书链接库中的过程，它们都是使用宏封装过程调用例子
==宏过程（或宏）是命名的汇编语句块，宏函数也是类似的，它们之间的区别在于宏函数可以返回一个常量值==
==IF,IFNB和IFIDNI等条件汇编伪指令可以检查宏参数是否有超出范围、是否缺少参数或数类型错误的情况。ECHO伪指令在汇编过程中显示错误信息，因此使得向程序员警告传递给宏的参数发生了错误成为可能。==
==替换操作符（&)能够解决对参数名的引用有歧义的情况；展开操作符（%)展开文本宏并常量表达式转化成文本；文本操作符（<>)把多个字符和文本定义为一个字符串整体；特殊文本字符操作符（!)强制预处理器把预定义的操作符作为普通字符对待。==
重复块伪指令可以减少程序中重复代码的数量，包括：

- ==WHILE伪指令根据一个布尔表达式来重复语句块。==
- ==REPEAT伪指令根据一个计数器来重复语句块。==
- ==FOR伪指令通过遍历一个符号列表中的每个符号来重复语句块。==
- ==FORC伪指令通过遍历一个字符串中的每个字符来重复语句块。==