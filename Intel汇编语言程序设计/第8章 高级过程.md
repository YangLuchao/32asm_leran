[toc]

本章要点
简介
堆栈框架
递归
.MODEL伪指令
INVOKE,ADDR,PROC和PROTO伪指令（可选）
创建多模块程序

# 8.1简介

本章着重讲述子例程和子例程调用的工作机制。探究使学习更加轻松的通用概念是很自然的一种倾向，因此本章以汇编语言作为低阶的编程工具，讲述过程的基本工作机制。换句话说，本章的内容也经常在C++和Java的中级程序设计课程，或者在名为程序设计语言的核心计算机科学课程上进行讲述。本章中讨论的下列主题是最基本的程序设计语言概念：

- 堆栈框架
- 变量的作用域和生存期
- 堆栈参数的类型
- 通过传递值或者传递引用来传递参数
- 在堆栈上创建和初始化局部变量
- 递归
- 编写多模块的程序
- 内存模型和语言关键字

本章部分选学的内容对MASM中的一些高级伪指令进行了介绍，这些伪指令是为方便应用程序员而设计的：

- INVOKE,PROC和PROTO伪指令
- USES和ADDR操作符

以上的汇编语言知识使你能够窥测编译器作者生成可执行程序代码的方法。
关于术语的注记：对于子例程（subroutine),不同的程序设计语言通常使用不同的术语。在C/C++中，称子例程为函数（function);在Java中，称子例程为方法（method);在MASM中称子例程为过程（procedure)。本章的重点在于讲述（C/C++中的）典型的子例程调用的底层实现。在本章开始部分讲述一般性的原则的时候，使用术语“子例程”；在本章后面讲述特定的MASMz伪指令（如PROC和PROTO)时，则使用特定的术语“过程”。

# 8.2 堆栈框架

堆栈框架(stack frame)也称活动记录(activation record),它是为传递的参数、子例程的返回地址、局部变量和保存的寄存器保留的堆栈空间。堆栈框架是按以下步骤创建的：

- 如果有传递的参数，则压入堆栈
- 子例程被调用，子例程的返回地址压入堆栈。
- 子例程开始执行时，EBP被压入堆栈。
- EBP设为ESP的值，从这时开始，EBP就被作为寻址所有子例程参数的基址指针使用了
- 如果有局部变量，ESP减去一个数值，以便在堆栈上为局部变量保留空间。
- 如果任何寄存器需要保存，则压入堆栈。

堆栈框架的结构受程序的内存模式以及参数传递约定的直接影响。
==学习通过堆栈传递参数的理由很充分：几乎所有的高级语言都使用堆栈传递参数==。例如，如果想要调用MS-Windows的应用编程接口(API),就必须通过堆栈传递参数。

## 8.2.1 堆栈参数

==有两种基本类型的子例程参数：寄存器参数和堆栈参数==

Irvine32和Irvine16库使用寄存器参数，本节讲述如何声明和使用堆栈参数
调用程序向子例程传递的值称为argument(参数，实参)，当这些值被子例程接收的时候，它们被称为parameter(参数，行程）

被调用的子例程访问调用子例程时压入堆栈的参数。使用寄存器参数可以优化程序的执行速度，但遗憾的是，这有可能会造成调用代码的混乱，因为有些寄存器在装入参数之前必须首先保存例如，调用DumpMem时就是这种情况：

```assembly
pushad
mov 	esi,OFFSET array	;起始偏移地址
mov 	ecx,LENGTHOF array	;大小
mov 	ebx,TYPE array		;双字格式
call 	DumpMem				;显示内存内容
popad
```

==另外一种更灵活的方法是堆栈参数，在调用子例程之前，参数首先压入堆栈。==例如，假设DumpMem使用堆栈参数，那么可以使用下面的代码进行调用：

```assembly
push TYPE arra
push LENGTHOF array
push OFFSET array
call DumpMer
```

==在进行子例程调用时在堆栈上压入了两类参数(值传递和引用传递)：==

- ==值参数（变量和常量的值）==
- ==引用参数（变量的地址）==

### 传递值

> 值传递，重点，堆栈上压入变量值的副本

==通过在堆栈上压人变量值的一份副本的方式传递参数，就称为传递值(pass by value),或简称为传值。==假设要调用一个子例程AddTwo,向该过程传递两个32位整数：

```assembly
.data
	val1 DWORD 5
	Val2 DWORD 6
.cade
	push val2
	push val1
	call AddTwo
```

下面是在CALL指令执行之前的堆栈示意图：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.4i55qv1uwb60.webp)

C++中等价的函数调用是：

```c++
int sum = AddTwo(vall, val2);
```

注意参数在堆栈上是以相反的顺序压栈的，这也是C/C+语言的调用规范。

### 传递引用

> 引用传递，传递的是对象的地址

==传递引用(pass by reference)的参数是一个对象的地址==。下面的语句调用了Swap，通过引用传递两个参数：

```assembly
push OFFSET val2
push OFFSET vall
call Swap
```

下面是调用Swap前堆栈的示意图：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6z75ba3g1js0.webp)

下面等价的C/C++函数调用传递的是val1和val2的地址：

```c++
Swap(&va11, &va12);
```

### 传递数组

前面讲述的传递值的规则有一个例外，那就是在传递数组参数时，高级语言总是传递引用，通过传递值的方式传递大量数据是完全不切实际的，因为传值的方式直接在堆栈上压入数据，这会降低程序的执行速度并用光宝贵的堆栈空间。例如下面的语句向子例程ArrayFill传递array的偏移地址：

```assembly
.data
	array DWORD 50 DUP(?)
.code
	push OFFSET array
	call ArrayFill
```

### 堆栈参数的访问(C/C++)

在调用函数时，C/C++程序使用标准的方法初始化和访问参数。C/C++中的函数以序言(prologue)开始，序言部分的代码保存了EBP寄存器，并使EBP指向当时堆栈的顶部，函数还有可能把一些寄存器压栈，这些寄存器的值将在函数返回的时候恢复。函数以收尾(epilogue)代码结束，在这部分代码中，EBP寄存器被恢复，RET指令从函数返回。

#### 例子AddTwo

下面用C编写的AddTwo函数接收两个整数参数（通过传值的方式传递）并返回其和：

```c++
int AddTwo(int x, int y)
{
	return x + y;
}
```

下面给出一个等价的汇编语言实现。在序言部分，AddTwo把EBP压栈以保存其值：

```assembly
AddTwo PROC
	push ebp
```

接下来，EBP设为ESP的值，因此EBP可作为AddTwo的堆栈框架的基址指针使用：

```assembly
AddTwo 		PROC
	push 	ebp
	mov 	ebp,esp
```

在这两条指令执行完后，堆栈框架的内容如下图所示，图中所示堆栈的每个数据项都是双字：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.23y5xto4n0ww.webp)

AddTwo还可以把其他的寄存器压栈，这不会改变堆栈中参数的地址相对于EBP的偏移，随后的代码中，ESP有可能会改变其值，但EBP通常不会。

### 访问堆栈参数

C/C++函数使用相对基址寻址方式访问堆栈参数，EBP用作基址寄存器，偏移部分是一个常量。函数一般通过EAX返回一个32位的值，下面AddTwo的实现代码把两个堆栈参数相加并在EAX中返回它们的和：

```assembly
AddTwo PROC
	push 	ebp
	mov 	ebp,esp			;堆栈框架的基址
	mov 	eax,[ebp+12]	;第二个参数
	add 	eax,[ebp+8]		;第一个参数
	pop ebp
	ret
AddTWO ENDP
```

### 堆栈的清理

在子例程返回时，必须要有某种方法清除堆栈上的参数，否则就会导致内存泄露以及堆栈的破坏。假设main中调用AddTwo的语句如下：

```assembly
push 6
push 5
call AddTwo
```

下面是从调用返回后堆栈的示意图：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6i2673hhdfk0.webp)

在main中，我们可以忽略这个问题并期望程序正常结束。不过如果在一个循环中调用AddTwo堆栈就有可能溢出，因为每次调用都会占用8个字节的堆栈空间。如果Example1调用了AddTwo，main又调用了Example1,那么就会导致更严重的问题：

```assembly
main PROC
	call 	Example1
	exit
main ENDP
Example1 PROC
	push 5
	push 6
	call AddTwo
	ret				;堆栈被破坏了！
Example1 ENDP
```

Example1中的RET指令返回时，ESP指向5而非main中的返回地址，不用多说你也知道了，程序转移到地址5执行，这将使程序崩溃。![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.43nzmkqf4hc0.webp)

对于这个问题，一种简单的解决方法是在CALL指令后使用一条ADD指令给ESP加上一个值，以使ESP指向正确的返回地址

```assembly
Examplel PROC
	push 	5
	push 	6
	call 	AddTwo
	add 	esp,8		;从堆栈中移除参数
	ret					;堆栈正常了
Example1 ENDP
```

这实际上也就是C/C++程序所使用的方法。

### STDCALL调用约定(Calling Convention)

处理堆栈清理问题的另一种方法是使用STDCALL调用约定，可以在AddTwo过程中的RET指令后提供一个整数参数以修复ESP的值，这个整数值必须等于堆栈参数消耗的堆栈空间字节数。

```assembly
AddTwo PROC
	push 	ebp
	mov 	ebp,esp			;堆栈框架的基址
	mov	 	eax,[ebp+12]	;第二个参数
	add 	eax,[ebp+8]		;第一个参数
	pop 	ebp
	ret 	8				;清理堆栈
AddTWO ENDP
```

这样一来，==上面堆栈清理的问题就简化了：谁应该对清理堆栈负责？是调用子例程的代码，还是子例程本身？这两种方式都有各自的优缺点：STDCALL减少了为子例程调用生成的代码数量（只有一条指令）并且能够确保调用者永远不会忘记清理堆栈；另一方面，C调用约定允许子例程声明可变数目的参数，由调用者决定要传递多少参数。==例子之一是printf函数，其参数数目决定于格式化串参数中格式符的数量：

```c
intx = 5;
floaty = 3.2;
printf("Printing values:%d,%f,%c",x,y,z);
```

C编译器在堆栈上按（和参数列表）相反的顺序压入参数，并（通过宏）传递实际参数数目，承数本身（通过宏）获取参数的数目并（通过宏）逐个对参数进行访问。在函数中，由于事先不知道调用者要传递多少个参数，所以没有在RET指令后指定参数占用堆栈空间字节数的便捷方法，清理堆栈的责任只能留给调用者了。

为同MS-Windows API兼容，Irvine32库使用STDCALL调用约定，Irvine16库也使用了同样的调用约定，目的是为了和Irvine32库兼容
从现在开始，除非明确说明，假设所有的例子过程均使用STDCALL调用约定。从现在开始，将使用“过程”一词指代子例程，因为本书几乎所有的例子都是用汇编语言编写的

### 通过堆栈传递8位和16位的参数

在保护模式下传递堆栈参数时，最好使用32位的操作数，虽然可以在堆栈上压入16位的操作数，但这样做会使得ESP无法对齐在双字地址边界上，由此可能会导致发生页故障，程序的性能也可能会降低。==因此在传递8位或16位堆栈参数时，应把它扩展到32位再压栈。==
下面的Uppercase过程接收一个字符参数并在AL中返回其大写形式：

```assembly
Uppercase 	PROC
	push 	ebp
	mov 	ebp,esp
	mov 	al,[esp+8]	;AL=字符
	cmp 	al,'a'		;小于'a'?
	jb 		L1			;是：什么也不做
	cmp 	al,'z'		;大于'z'?
	ja	 	L1			;是：什么也不做
	sub 	al,32		;否：进行转换
L1:
	pop		ebp
	ret 	4			;清理堆栈
Uppercase 	ENDP
```

如果向Uppercase传递字符文字量，PUSH指令自动把字符扩展到32位：

```assembly
push 'x'
call Uppercase
```

传递字符变量时需要格外小心，因为PUSH指令不允许8位的操作数：

```assembly
.data
	charVal BYTE 'x'
.code
	push charval		;语法错误
	call Uppercase
```

相反，应该使用MOVZX指令把字符值扩展至EAX:

```assembly
movzx eax,charVal	;带扩展传送
push eax
call Uppercase
```

### 16位参数的例子

假设要向前面给出的AddTwo过程传递两个16位的整数，由于该过程期望接收32位参数，因此下面的代码将导致语法错误：

```assembly
data
	word1 WORD 1234h
	word2 WORD 4111h
.code
	push 	word1
	call 	AddTwo		;错误
```

下面的代码在每个参数压栈之前首先进行零扩展，因此正确地调用了过程AddTwo:

```assembly
movzx 	eax,word1
push 	eax
movzx	eax,word2
call 	AddTwo		;和在EAX中
```

过程的调用者必须确保传递的参数和过程期望的参数相一致。就堆栈参数而言，其大小和顺序都是非常重要的！

### 传递长整数参数

==在使用堆栈向过程传递长整数（由多个字构成的）参数时，可以先把高位字压栈，然后再把低位字压栈，这样实际上是以小尾顺序（低字节在低地址）把长整数压栈了。==下面的WriteHex64过程通过堆栈接收一个64位的整数并以十六进制显示：

```assembly
WriteHex64 	PROC
	push 	ebp
	mov 	ebp,esp
	mov 	eax,[ebp+12]	;高双字
	call	WriteHex
	mov 	eax,[ebp+8]		;低双字
	call 	WriteHex
	pop 	ebp
	ret 	8
WriteHex64 ENDP
```

下面的例子在调用WriteHex64之前，首先把longVal的高半部分压栈，然后再把低半部分压栈：

```assembly
.data
	longVal DQ 1234567800ABCDEFh
.code 
	push DWORD PTR 1ongVal + 4		;高双字
	push DWORD PTR longVal			;低双字
	call WriteHex64
```

图8.1显示了WriteHex64过程在EBP压栈后的堆栈框架。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.58cqn9apvnk0.webp)

### 保存和恢复寄存器

子过程通常在修改寄存器之前保存其原来的值，以便在过程返回之前进行恢复。理想情况下，要保存的寄存器应在EBP设为ESP的值之后、为局部变量保留空间之前压栈，这有助于避免改变堆栈参数的相对偏移，例如下面的过程MySub有一个堆栈参数，它在把EBP设为ESP的值（以作为堆栈框架的基址指针）之后把ECX和EDX寄存器压栈，然后把堆栈参数装入EAX:

```assembly
MySub 	PROC
		push 	ebp		;保存基址指针
		mov 	ebp,esp	;堆栈框架的基址
		push 	ecx
		push 	edx		;保存EDX
		mov 	eax,[ebp+8];获取堆栈参数
...
		pop 	edx			;恢复已保存的寄存器
		pop		ecx
		pop 	ebp			;恢复基址指针
		ret					;清理堆栈
MySub 	ENDP
```

EBP初始化之后，在整个过程内其值保持不变，ECX和EDX的压栈不影响堆栈中的参数相对于EBP的偏移，这是因为堆栈是向下增长的（参见图8.2)。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.2502nf94t534.webp)

### USES 操作符对堆栈的影响

==USES操作符（参见第5章）后跟要在过程开始时保存并在过程结束时恢复的寄存器列表，对于列表中的每个寄存器，MASM自动生成合适的PUSH和POP指令。==注意：==使用显式堆栈参数的过程应避免使用USES操作符==。我们来看一下这是为什么，下面的MySub1过程使用了USES操作符保存和恢复ECX及EDX:

```assembly
MySub1 PROC USES ecx edx
	ret
MySub1 ENDP
```

下面是汇编MySub1时MASM生成的代码：

```assembly
push ecx
push edx
pop edx
pop ecx
```

假设在MySub2中把USES和堆栈参数一起使用，我们预期第一个参数在堆栈位置EBP+8处：

```assembly
MySub2 	PROC USES ecx edx
		push ebp		;保存基址指针
		mov ebp,esp		;堆栈框架的基址
		mov eax,[ebp+8]	;获取堆栈参数
		pop ebp			;恢复基址指针
		ret 4			;清理堆栈
MySub2 ENDP
```

下面是MASM为MySub2生成的代码：

```assembly
push ecx
push edx
push ebp
mov  ebp,esp
mov  eax,dword ptr[ebp+8];错误的位置！
pop  ebp
pop  ecx
ret  4
```

由于MASM在过程的开始插入了PUSH指令，因此改变了堆栈参数相对于EBP的偏移地址，进而导致发生了错误。图8.3表明现在必须通过[EBP+16]引用第一个堆栈参数。与标志的过程序言代码相反，USES操作符在保存EBP之前修改了堆栈。在8.5.3节将看到，PROC伪指令有一种声明堆栈参数的高级语法格式，使用该格式时再使用USES操作符不会发生这样的问题。
==使用显式堆栈参数的过程应避免使用USES操作符==。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6k7rf9ie1i80.webp)

## 8.2.2 局部变量

在高级语言程序中，在单个过程中创建、使用和销毁的变量称为局部变量（local variable)。局部变量与过程之外声明的全局变量相比有明显的优点：

- 只有在局部变量所在过程之内的语句才能够看到和修改局部变量。这个特点有助于避免程序源码中多处修改一个变量导致的bug。
- 局部变量使用的存储空间在过程结束后即释放。
- 一个过程内的局部变量的名字可以和其他过程内的局部变量名相同，不会发生名字冲突。这个特性对于大程序是非常有用的。在大程序中，变量名相同的可能性还是比较大的
- 对递归过程以及可能由多个线程同时执行的过程而言，局部变量是必需的。

局部变量是在运行时栈上创建的。在内存中其位置通常在基址指针(EBP)之下，尽管在汇编时不能给定默认值，但可以在运行时初始化。在汇编语言中创建局部变量时，可以使用和C/C++类似的技术
例子：下面的C++函数声明了局部变量X和Y:

```c++
void MySub()
{ 
	int X = 10;
 	int Y = 20;
}
```

我们以编译后的C++程序为例，看看C++编译器是如何分配局部变量的。每个堆栈项都是32位的双字，因此每个变量的大小是4个字节（按4的倍数向上取整）,程序为这两个变量保留了8个字节的空间。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6ymynd3hu9s0.webp)

MySub函数的反汇编代码（通过调试器的反汇编窗口查看）展示了C++程序是以何种方式创建局部变量、赋值以及从堆栈上移除变量的，MySub函数使用的是C调用约定：

```assembly
MySub PROC
	push 	ebp
	mov 	ebp,esp		;创建局部变量
	sub 	esp,8
	mov 	DWORD PTR [ebp-4],10 ; X
	mov 	DWORD PTR [ebp-8],20 ;Y
	mov 	esp,ebp		;从堆栈上删除局部变量
	pop 	ebp
	ret
MySub ENDP
```

图8.4显示了局部变量初始化之后堆栈框架的情况。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.2zp8erfe0c80.webp)

在过程返回之前，函数通过把EBP的值赋给ESP恢复了堆栈指针的值，下面的语句的效果相当于从堆栈上释放了局部变量：

```assembly
mov 	esp,ebp	;从堆栈上删除局部变量
```

如果去掉了上面的语句，POP EBP指令将使得EBP等于10，ET指令导致控制转移到内存地址10处继续执行，最后当然会导致处理器发生异常了。下面是删除了上面的语句的MySub版本：

```assembly
MySub PROC
	push 	ebp
	mov 	ebp,esp
	sub 	esp,8		;创建局部变量
	mov 	DWORD PTR [ebp-4],10	;X
	mov 	DWORD PTR [ebp-8],20	;Y
	pop 	ebp
	ret					;返回了到无效地址！
MySub ENDP
```

### 局部变量符号

为使代码更加易读，可以给每个变量的引用地址都定义一个符号并在代码中
使用这些符号：

```assembly
X_local EQU DWORD PTR [ebp-4]
Y_local EQU DWORD PTR [ebp-8]
MySub	PROC
		push 	ebp
		sub 	esp		;创建局部变量
		mov 	x_local,10;X
		mov 	Y_local,20;Y
		mov 	esp,ebp		;从堆栈上删除局部变量
		pop 	ebp
		ret
MySub 	ENDP
```

### 访问引用参数

子过程通常使用相对基址寻址方式访问引用参数，这是由于每个引用参数都是一个指针，实际上引用参数是要被装入到寄存器中作为间接操作数使用的。例如，假设一个指向数组的指针位于堆栈位置[ebp+12]处，下面的语句把该指针复制到ESI中：

```assembly
mov 	esi,[ebp+12]		;指向数组的指针
```

### 例子：ArrayFill。

下面将要给出的ArrayFill过程，使用16位的随机整数序列填充一个数组。该过程接收两个参数：第一个参数是数组的偏移，第二个参数是指示数组长度的整数。第一个参数通过传递引用方式来传递，第二个参数通过传值方式传递。下面的代码是调用示例：

```assembly
.data
	count = 100
	array WORD count DUP(?)
.code
	push OFFSET array
	push COUNT
	call ArrayFill
```

在ArrayFill过程中，下面的代码初始化了堆栈框架的指针(EBP):

```assembly
ArrayFi11 	PROC
			push 	ebp
			mov 	ebp,esp
```

现在堆栈框架如下图所示，其中包含了array的偏移，count,返回地址以及保存的EBP的值：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.2grnyuf5ily0.webp)

在ArrayFill过程中，首先保存通用寄存器，然后取得参数，最后填充数组：

```assembly
ArrayFi11 	PROC
			push 	ebp
			mov 	ebp,esp
			pushad	;保存寄存器
			mov 	esi,[ebp+12]	;array的偏移
			mov 	ecx,[ebp+8]		;array的大小
			cmp		ecx,0			;ECX==0?
			je 		L2				;是：跳过循环
L1:
			mov 	ecx,1000h		;获取0~FFFFh之间的随机数
			call 	kandomkange		;来自本书的链接库
			mov 	[esi],ax		;在数组中插入值
			add 	esi,TYPE WORD	;下一个元素
			loop 	L1
L2:
			popad					;恢复寄存器
			pop 	ebp
			ret 	8				;清理堆栈
ArrayFill ENDP
```

### LEA 指令

LEA指令返回间接操作数的偏移地址。由于间接操作数可能使用一个或多个寄存器，因此其偏移值是在运行时计算的。为说明LEA指令如何使用，下面首先看一个C++程序的例子，程序声明了一个局部的字节数组myString并在赋值时引用：

```c
void makeArray()
{
	char myString[30];
	for(int i = 0; i < 30; i++)
		myString[i] ='*';
}
```

下面等价的汇编代码在堆栈上为myString分配空间并把myString的地址赋予间接操作数ESI,虽然数组只有30个字节，但ESP还是减去了32,以使其按双字边界对齐，注意下面的代码是如何使用LEA指令为ESI赋数组的偏移地址的：

```assembly
makeArray 	PROC
			push 	ebp
			mov	 	ebp,esp
			sub 	esp,32		;myString位于EBP-30
			lea 	esi,[ebp-30];加载myString的地址
			mov 	ecx,30		;循环计数器
L1: 
			mov 	BYTE PTR [esi],'*'	;填充一个位置
			inc		esi			;移到下一个位置
			loop	L1			;继续循环直到ECX=0
			add 	esp,32		;删除array(恢复ESP)
			pop 	ebp
			ret
makeArray 	ENDP
```

==使用OFFSET操作符获取堆栈参数的地址是不可能的==，因为OFFSET只能获取在编译时就已知的地址值。下面的语句汇编时将出错：

```assembly
mov 	esi,OFFSET [ebp-30]		;错误
```

## 8.2.3 ENTER和LEAVE指令

==ENTER指令自动为被调用过程创建堆栈框架，它为局部变量保留堆栈空间并在堆栈上保存EBP，该指令执行以下三个动作：==

1. ==在堆栈上压入EBP(push ebp)==
2. ==把EBP设为堆栈框架的基指针（mov ebp,esp)==
3. ==为局部变量保留空间（sub esp,numbytes)==

==ENTER指令有两个操作数：==

1. ==第一个操作数是个常量，用于指定要为局部变量保留出多少堆栈空间(numbytes)==
2. ==第二个操作数指定过程的嵌套层次(nestinglevel):==

```assembly
ENTER numbytes,nestinglevel
```

==两个操作数都是立即数。numbytes总是向上取整为4的倍数，以使ESP按双字边界地址对齐nestinglevel决定了从调用过程复制到当前堆栈框架中的堆栈框架指针的数目==。==在本书的程序中nestinglevel总是0，IntelIA-32手册解释了ENTER指令在块结构的语言中是如何支持嵌套层次的！==

#### 例子1

下面的例子声明了一个没有任何局部变量的过程：

```assembly
MySub PROC
	enter 0,0
```

这与下面的指令是等价的：

```assembly
MySub 	PROC
		push 	ebp
		mov 	ebp,esp
```

#### 例子2

ENTER指令为局部变量保留了8字节的堆栈空间：

```assembly
MySub PROC
	enter 8,0
```

它与下面的指令是等价的：

```assembly
MySub PROC
	push ebp
	mov  ebp,esp
	sub  esp,8
```

图8.5给出了ENTER指令执行前后的堆栈示意图。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.2lmmwnqr6ru0.webp)

==如果要使用ENTER指令的话，强烈建议在同一过程的结尾处使用LEAVE指令。否则，为局部变量创建的堆栈空间有可能不会被释放，此外还可能导致RET指令从堆栈上弹出错误的返回地址==。

### LEAVE指令

==LEAVE指令释放一个过程的堆栈框架。LEAVE指令执行与前面ENTER指令相反的动作，把EBP和ESP恢复为过程开始时的值。==再次以MySub过程为例：

```assembly
MySub PROC
	enter 8,0
	leave
	ret
MySub ENDP
```

下面的指令与上面的指令是等价的，它首先为局部变量保留8字节的堆栈空间然后丢弃：

```assembly
MySub 	PROC
		push ebp
		mov  ebp,esp
		sub  esp,8
		mov  esp,ebp
		popebp
		ret
MySub 	ENDP
```

## 8.2.4 LOCAL伪指令

==LOCAL伪指令在过程内声明一个或多个命名局部变量，并同时赋予变量相应的尺寸属性。语句必须紧接在PROC伪指令所在行之后，==格式如下所示：

```assembly
LOCAL 变量列表
```

其中变量列表是一系列的变量定义，中间以逗号分隔，列表可能会占用多行。每个变量定义的格式如下：

```assembly
标号:类型
```

==标号可以是任何有效的标识符，类型既可以是标准类型(WORD,DWORD等)也可以是用户自定义的类型==(结构和其他用户自定义的类型在第10章中讲述)。
例子：MySub过程包含一个名为var1,类型是BYTE的局部变量：

```assembly
MySub PROC
	LOCAL var1:BYTE
```

BubbleSort过程包含一个名为temp的双字局部变量和一个名为SwapFlag的字节类型局部变量：

```assembly
BubbleSort PROC
	LOCAL temp:DWORD,SwapFlag:BYTE
```

Merge过程包含一个名为pAray。类型是PTR DWORD的指向一个16位整数的局部变量

```assembly
Merge PROC
	LOCAL pArray:PTR WORD
```

局部变量TempArray是一个包含10个双字的数组，注意指定数组大小的方括号的用法：

```assembly
LOCAL 	TempArray[10]:DWORD
```

### MASM生成的代码

通过查看汇编代码，可以看到在使用LOCAL伪指令时MASM生成的相应代码是什么下面的Example1过程只定义了一个双字局部变量：

```assembly
Examplel PROC
	LOCAL 	temp:DWORD
	mov 	eax,temp
Examplel ENDP
```

MASM为Examplel生成的代码如下所示，从中可以看到ESP减掉了4以便给双字局部变量留出空间：

```assembly
	push 	ebp
	mov 	ebp,OFFFFFFFCh	;ESP-4
	mov 	eax,[ebp-4]
	leave
	ret
```

下面是Example1的堆栈框架示意图

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.7dxrq2cfh680.webp)

### 非双字局部变量

在声明不同尺寸大小的局部变量时，LOCAL伪指令的行为是非常有趣的，==LOCAL伪指令根据变量的大小的不同，为其分配空间的方法也是不一样的：对于8位变量，在第一个可用的字节处为其分配空间；对于16位变量，在第一个可用的偶数地址处为其分配空间；对于32位变量，在第一个可用的双字对齐边界地址处为其分配空间。==
下面来看几个例子。过程Example1包含了一个名为var1的字节类型的局部变量：

```assembly
Example1 PROC
	LOCAL 	var1:BYTE
	mov 	al,var1	;[EBP-1]
	ret
Examplel ENDP
```

==由于堆栈偏移是32位的，读者可能认为var1会被分配在EBP-4的位置，不过与读者的预期相反，ESP减掉了4,var1被分配在了EBP-1处，堆栈下面其余的3个字节是未使用（以nu表示）的==，如图8.6所示。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6pdka3uusrc0.webp)

过程Example2定义了一个双字变量，其后又定义了1个字节变量：

```assembly
Example2 PROC
	LOCAL temp:DWORD,SwapFlag:BYTE
	;
	ret
Example2 ENDP
```

下面是MASM为过程Example2生成的代码，其中的ADD指令将ESP加(-8),这样就在ESP和EBP之间制造一个“间隙”，从而为两个局部变量保留了空间：

```assembly
push ebp
	mov ebp,esp
	add esp,0FFFFFFF8h	;ESP加（-8)
	mov eax,[ebp-4]		; temp
	mov bl,[ebp-5]		; SwapFlag
	leave
	ret
```

尽管SwapFlag只占用1个字节，ESP还是向下对齐到了下一个双字边界的堆栈位置上了。
图8.7给出了以字节形式表示的堆栈框架的详图，图中显示了SwapFlag的位置以及它下面的3个未用的字节空间（以nu标示）。

### 保留额外的堆栈空间

如果准备创建大于几百个字节的局部数组变量，一定要在运行时栈上保留（分配）出足够的空间，这可以通过.STACK伪指令来完成。例如在库文件Irvine32.inc中，使用下面的`.STACK`伪指令保留了4096字节的堆栈空间：

```
.stack 4096
```

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.5zv3a3ft2600.webp)

如果过程调用是嵌套的，栈空间必须足够大，以容纳程序运行期间任意时刻的所有局部变量
例如，假设Sub1调用了Sub2,Sub2又调用了Sub3,每个过程都可能有一个局部数组变量：

```assembly
Sub1 PROC
	LOCAL,array1[50]:DWORD	;200字节
Sub2 PROC
	LOCAL array2[80]:WORD	;160字节
Sub3 PROC
	LOCAL array3[300]:BYTE	;300字节
```

当程序进入Sub3过程的时候，堆栈上包含了Sub1,Sub2和Sub3全部的局部变量，因此局部变量占用了660字节的堆栈空间，此外两个过程的返回地址还要占用的8个字节，如果在过程中向堆栈上压入了寄存器的话，也要占用一定量的堆栈空间。

## 8.2.5 过程WriteStackFrame

本书链接库中有一个有用的过程WriteStackFrame,该过程能够显示当前过程的堆栈框架的内容：过程的堆栈参数、返回地址、局部变量以及保存的寄存器。这个过程是由Pacific Lutheran University的James Brink教授无私提供的。下面是过程的原型声明：

```assembly
WriteStackFrame PROTO,
	numParam:DWORD,		;传递的参数的数目
	numLocalVal:DWORD,	;双字局部变量的数目
	numSavedReg:DWORD	;保存的寄存器的数目
;下面的代码片段解释了WriteStackFrame的用法：
main PROC
	mov eax,0EAEAEAEAh
	mov ebx,0EBEBEBEBh
	INVOKE aProc,1111h,2222h;传递两个整数参数
	exit
main ENDP
;
aProc PROC USES eax ebx,	;保护寄存器
	X:DWORD,y:DWORD			;形参
	LOCAL a:DWORD,b:DWORD	;局部变量
	PARAMS = 2
	LOCALS = 2
	SAVED_REGS = 2
	mov 	a,0AAAAh
	mov 	b,0BBBBh
	INVOKE WriteStackFrame, PARAMS, LOCALS, SAVED_RECS
```

下面是该调用产生的输出示例：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.32w8mhdf29s0.webp)

此外还有一个名为WriteStackFrameName的过程，该过程多了一个参数用于存放拥有堆栈框架的过程的名字：

```assembly
WriteStackFrameName PROTO,
	numParam:DWORD,		;传递的参数的数目
	numLocalVal:DWORD,	;双字局部变量的数目
	numSavedReg:DWORD,	;保存的寄存器的数目
	procName:PTR BYTE
```

与该过程相关的例子和文档请参见例子程序Test_WriteStackFrame.asm。除此之外，源代码(\Lib32\Irvine32.asm)中也包含了详细的文档。

# 8.3 递归

递归子例程(recursive subroutine)是直接或间接调用自身的子例程。当操作有某种重复模式的数据结构时，递归(recursion)是一种非常有力的工具，一个例子就是程序必须回溯其路径的链表和连通图。

### 无尽循环递归

最显而易见的递归类型就是一个过程对自身进行调用。在下面的程序中
Endless过程不断重复调用自己，永远也不会停止。

```assembly
TITIEEndlessRecursion	(Endless,asm)
INCLUDE Irvine32.inc
.data
	endlessstr BYTE"This recursion never stops",0
.code
main PROC
	call Endless
	exit
main ENDP
;
Endless PROC
	mov edx,OFFSET endlessStr
	call writestring
	call Endless
	ret				;永远不会执行
	Fndless FNDP
END main
```

当然，这个例子没有任何实际价值。每次过程调用自身的时候，CALL指令在堆栈上压入返回地址并用掉4字节的堆栈空间，RET指令永远也不会执行。
如果能够访问性能监视工具，如Windows2000任务管理器，那么打开它并单击性能对话框选项卡，然后运行本章目录下的Endless.exe程序，内存会逐渐被填满，程序也会消耗100%的CPU资源，几分钟后程序堆栈就会溢出并导致处理器异常（程序将挂起）。

## 8.3.1 递归求和

有实际意义的递归过程总会包含一个终止条件，只要终止条件为真，程序就会执行所有挂起的RET指令，堆栈就被展开了(unwind)。为了说明这一点，我们创建一个CalcSum递归过程计算从1到n的和，n是一个通过ECX传递的输入参数，过程CalSum在EAX中返回和。

```assembly
TITLE Sum of Integers	(CSum.asm)
INCLUDE Irvine32.inc
.code
main PROC
	mov ecx,5	; count = 5
	mov eax,0	;存放和
	call CalcSum	;计算和
L1:
	call WriteDec	;显示EAX
	call Crlf		;换行
	exit
main ENDP
;
CalcSum PROC
; Calculates the sum of a list of integers
; Receives : ecx = count
; Returns : eax = sum
	cmp ecx,0	;检查计数器的值
	jz L2		;为0则退出
	add eax,ecx	;否则，与和相加
	dec ecx		;计数器减1
	call CalcSum	;递归调用
L2:
	ret
CalcSum ENDP
end Main
```

CalcSum的前两行检查计数器并在ECX=0时退出。退出代码忽略了进一步的递归调用，当第一次抵达RET指令的时候，就恢复到了上一级CalcSum调用，然后再返回到其上一级的调用，依次类推。表8.1显示了CALL指令在堆栈上压入的返回地址以及当时的ECX(计数器）和EAX的值（和）。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.3g3mgf6ihm80.webp)

从这个例子可以看到，即使是最简单的递归程序也要使用大量堆栈。每发生一次过程调用占用的堆栈空间最少是4个字节，因为过程的返回地址必须保存在堆栈上。

## 8.3.2 计算阶乘

递归过程通常通过堆栈参数存储临时数据，在递归展开时，在堆栈上保存的数据就可能很有用了。下面的例子计算整数n的阶乘。阶乘(factorial)算法用于计算n!,其中n是无符号整数。

第一次调用factorial函数时，参数n是起始数字，下面是C/C++/Java的语法格式编写的代码：

```assembly
int function factorial(int n)
{
	if (n == 0)
		return 1;
	else
		return n * factorial(n-1);
}
```

对于给定的任意数字n,假设我们可以计算n-1的阶乘，这样就可以持续减少n,直到n等于0为止。根据定义，0!等于1。在返回到原始表达式n!的时候，我们累积计算每次乘法之积。

例如计算5!的时候，递归算法中处理的数字在图8.8左面一栏递减并在右面一栏恢复：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.59zpx9bun8k0.webp)

例子程序：下面的汇编语言程序中包含了一个名为Factorial的过程，Factorial使用递归计算阶乘。我们通过堆栈向Factorial过程传递整数n(在0~12之间的无符号整数）,最后在EA中返回阶乘值。因为使用的是32位寄存器存放阶乘，因此可容纳的最大阶乘值是12!(479001600)。

```assembly
TITLE Calculating a Factorial (Fact.asm)
INCLUDE Irvine32.inc
.code
main PROC
	push	12	;计算12!
	call 	Factorial	;计算阶乘（EAX)
ReturnMain:
	call 	WriteDec	;显示
	call 	Crlf
	exit
main ENDP
;
Factorial PROC
; Calculates a factorial .
; Receives:[ebp+8]=n,the number to calculate
; Returns : eax = the factorial of n
	push ebp
	mov  ebp,esp
	mov  eax,[ebp+8]	;获取n
	cmp	 eax,0			;n>0?
	ja 	 L1		;是：继续
	mov  eax,1	;否：返回1
	jmp  L2
L1:
	dec eax
	push eax
; Factorial (n-1)
	call Factorial
; Instructions from this point on execute when each
; recursive call returns.
ReturnFact:
	mov  ebx,[ebp+8]	;获取n
;EDX:EAX=EAX*EBX
	mul ebx
L2:
	pop ebp		;返回EAX的值
	ret		4	;清理堆栈
Factorial ENDP
END main
```

调用Factorial时，call指令后面一条指令的偏移地址压入堆栈，在main中，是标号ReturnMain的偏移地址；在Factorial中，是标号ReturnFact。几次递归调用之后的堆栈如图8.9所示，可以看到每次Factorial调用自身的时候，n和EBP的新值都要被压入堆栈。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.7gzgivp1gmg0.webp)

在例子中，==每次过程调用都要使用12字节的堆栈空间。在Factorial调用自身之前，n-1被作为输入参数压入堆栈，过程在EAX中返回阶乘值，这个值然后与调用之前在堆栈上压入的值相乘。==

# 8.4 .MODEL 伪指令

==MASM使用.MODEL伪指令决定程序的几个重要特性：内存模式类型、过程命名方案和参数传递约定==。后二者在涉及到汇编语言与其他程序设计语言的接口的时候特别重要.MODEL伪指令的格式是：

```
.MODEL 内存模式 [,模式选项]
```

### 内存模式：

内存模式可以是表8.2中的任意一种模式，其中除平坦内存模式之外的所有模都只能用于16位的实地址模式编程。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.1yilpbvhbcz.webp)

到现在为止，本书给出的所有实地址模式程序使用的都是小型内存模式，因为该模式的程序把所有的代码都放在一个段内，而所有的数据（包括堆栈）放在另外一个段中，这样只需要控制代码和数据的偏移即可，因为段地址不会改变。
保护模式程序使用平坦内存模式，所有的偏移都是32位的，代码和数据最大可达4GB。例如，Irvine32.inc文件包含下面的`.MODEL`伪指令：

```assembly
.model flat,STDCALL
```

### 模式选项

模式选项（在.MODEL伪指令中）可包含语言选项关键字或堆栈的远近选项。语言选项决定了过程和公共符号的调用约定及命名约定。堆栈的远近选项既可以是NEARSTACK,也可以是FARSTACK。

## 8.4.1 语言选项关键字

让我们进一步看看`.MODEL`伪指令中使用的语言选项关键字。可用的关键字有`C,BASIC,FORTRAN,PASCAL,SYSCALL和STDCALL`。C,BASIC,FORTRAN和PASCAL关键字使汇编语言程序员能够创建与这些语言兼容的汇编程序；SYSCALL和STDCALL是其他语言关键字的变种。本书解释了C和STDCALL关键字，下面的例子中使用的都是平坦内存模式：

```
.model flat, C
.model flat, STDCALL
```

本章中的大部分例子程序使用的都是STDCALL语言关键字，这也是调用MS-Windows函数时所使用的。在第12章中，汇编语言代码同C/C+程序链接时将使用C语言关键字。

### 关键字STDCALL

> 传参入栈从右往左
>
> 函数命名加@n，n是 所有参数所占字节数
>
> 由子过程负责堆栈平衡

==STDCALL关键字指定过程按照从右到左（从最后一个到第一个）的反向顺序压入参数==，假设高级语言中的函数调用语句如下：

```c
AddTwo(5,6);
```

等价的汇编语言代码是：

```assembly
push 6
push 5
call AddTwo
```

另外要考虑的一个重要因素是在过程调用之后如何从堆栈上移除参数。STDCALL关键字要求过程在RET指令后面提供一个常量操作数，RET指令在堆栈上弹出返回地址之后把该常量同ESP相加：

```assembly
AddTwo PROC
	push ebp
	mov ebp,esp
	mov eax,[ebp+12]	;第一个参数
	add eax,[ebp+8]		;第二个参数
	pop	ebp
	ret 8				;清理堆栈
AddTwo ENDPP
```

通过对堆栈指针加8,我们把堆栈指针重设为调用程序在堆栈上压入参数之前的值。
最后，STDCALL把要导出的过程（公共过程）名修改为以下格式：

```c
_name@nn
```

过程名开头加了一条下划线，并且在@符号后面加了表示过程参数使用的字节数的整数（向上取整为4的倍数）。==例如AddTwo过程有两个双字参数，那么汇编器传递给链接器的名字就是\_AddTwo@8==
注意：LINK32.EXE是大小写敏感的，因此链接器认为\_MYSUB@8和\_MySub@8是不同的名字。要想查看OBJ文件中的所有过程名，可以使用Visual Studio中的DUMPBIN实用工具并加/SYMBOLS选项。

### 关键字C

> 参数入栈从右到左
>
> 堆栈平衡由主函数负责

==C语言关键字要求过程参数以反向顺序（从最后一个到第一个）压栈，这一点同STDCALL语言关键字是一样的。使用C语言关键字时过程调用后堆栈参数移除的任务落在调用者的身上，在调用程序中，ESP要加上一个常量，把堆栈指针重设为参数压入之前的值==：

```assembly
push 6			;第二个参数
push 5			;第一个参数
call AddTwo
add esp,8		;清理堆栈
```

==C语言关键字在外部过程名之前添加一个下划线字符，==例如：

```
_AddTwo
```

# 8.5 INVOKE,ADDR,PROC和PROTO(可选）

INVOKE,ADDR,PROC和PROTO伪指令是定义和调用过程的有力工具。这些伪指令在很多方面都使得使用汇编语言像使用高级程序设计语言一样方便。==从教育学的角度来看，这些伪指令的使用是倍受争议的，因为它们隐藏了运行时栈的结构，学习计算机基础的读者最好深入理解子例程调用的底层机制的细节。==
使用高级过程伪指令在某些情况下还是非常有助于程序编写的，比如在程序跨越模块边界调用过程时，==PROTO伪指令可以检查过程的参数列表和过程的声明是否一致，从而验证过程调用是否正确==，这类特性鼓励了高级汇编语言程序员对这些高级MASM伪指令使用，以享受这些伪指令提供的便利

## 8.5.1 INVOKE 伪指令

==INVOKE伪指令（按.MODEL伪指令语言关键字指定的顺序）在堆栈上压入参数并调用过程INVOKE伪指令是CALL指令的增强替代品，它允许在一行代码中传递多个参数。==下面是该伪指令的通用格式：

```assembly
INVOKE 过程名 [,参数列表]
```

==参数列表是要传递给过程的包含多个参数的列表，参数之间用逗号分隔，参数列表是可选的==
例如，如果使用CALL指令，我们在几条PUSH指令之后调用DumpArray过程：

```assembly
push TYPE array
push LENCTHOF array
call Dumper arra
```

使用INVOKE指令等价语句只要使用一行代码，参数以相反的顺序（与上例相比）列出（假设使用的是STDCALL语言关键字）:

```assembly
INVOKE DumpArray, OFFSET array, LENCTHOF array, TYPE array
```

INVOKE允许使用任意数量的参数，单个参数可以出现单独的一行上。下面的INVOKE语句还包含了有用的注释：

```assembly
INVOKE Dump Array	;显示内存块
OFFSET array,		;指向arr
LENGTHOF array,		;array的长度
TYPE array			;array每个项目的大小
```

INVOKE可使用参数类型如表8.3所示。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.vu1emlclr4w.webp)

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.68f34528yb00.webp)

#### 对EAX和EDX的改写

如果向过程传递的参数小于32个数据位，INVOKE伪指令可能会导致汇编器在参数压栈之前使用EAX或EDX对参数进行扩展，这有可能会破坏改写EAX或EDX的内容。可以总是向INVOKE传递32位的参数以避免这种行为，也可以在使用INVOKE伪指令调用过程之前首先保存EAX和EDX并在过程调用之后恢复。

## 8.5.2 ADDR 操作符

==ADDR 操作符可在使用INVOKE调用过程的时候传递指针参数==。例如，下面的INVOKE语句向FillArray过程传递myArray的地址：

```assembly
INVOKE FillArray, ADDR myArray
```

==通过ADDR传递的参数必须是一个汇编时的常量==，下面是错误的：

```assembly
INVOKE mySub, ADDR [ebp+12]	;错误
```

==ADDR操作符只能和INVOKE联用==，下面是错误的：

```assembly
mov esi, ADDR myArray	;错误
```

==根据程序采用的内存模式的要求的不同，ADDR返回一个近指针或一个远指针。保护模式程序中ADDR和OFFSET返回的都是32位的偏移值==（Irvine32.inc中的.MODEL伪指令指定了平坦内存模式）。
例子：下面的INVOKE伪指令调用过程Swap,调用时传递了一个双字数组的前两个元素的
地址：

```assembly
.data
	Array DWORD 20 DUP(?)
.code
	INVOKE Swap, ADDR Array ,ADDR [Array+4]
;下面是汇编器生成的相应代码，假设当前使用的是STDCALL:
push OFFSEI Array+4
push OFFSET Array
call Swap
```

## 8.5.3 PROC 伪指令

### ==PROC伪指令的格式==

PROC伪指令的基本格式如下：

```assembly
标号 PROC [属性] [USES 寄存器列表],参数列表
```

标号部分是用户自定义的标号，其创建规则与第3章介绍的标识符的创建规则一致。属性部分可以是以下之一：

```
[distance][langtype][visibility][prologue]
```

表8.4描述了每种属性。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.623qe5hz5jg0.webp)

### 参数列表

PROC伪指令允许声明的过程带一个命名参数的列表，以逗号分隔。过程的实现代码可以通过名字引用参数，而不是通过手工计算的堆栈偏移，如[EBP+8]:

```assembly
标号 PROC [属性] [USES 寄存器列表],
	参数1,
	参数2,
	参数n
```

注意第一个参数之前的逗号是必需的，但很容易漏掉。参数也可以在同一行上：

```assembly
标号 PROC [属性] [USES 寄存器列表],参数1,参数2,…，参数n
```

每个参数的格式如下：

```assembly
参数名:类型
```

参数名可以是赋予参数的任意名字，它的作用域局限于当前的过程之内（称为局部域）。同样的名字可在多个过程之中使用，但不能和全局的变量名或代码标号相同。参数的类型可以是以下类型之一：`BYTE,SBYTE,WORD,SWORD,DWORD,SDWORD,FWORD,QWORD或TBYTE`,还可以是修饰类型（qualified type),如指向已知类型的指针。下面是一些修饰类型的例子：

```assembly
PTR BYTE
PTR SBYTE
PTR WORD
PTR SWORD
PTR DWORD
PTR SDWORD
PTR QWORD
PTR TBYTE
```

尽管还可以在这些类型前加上NEAR和FAR属性，但一般只有在比较特殊的程序中才这样使用。修饰类型还可以使用TYPEDEF和STRUCT伪指令定义，TYPEDEF和STRUCT伪指令将在第10章中介绍。

### 例子1

下面的AddTwo过程接收两个双字参数并在EAX中返回其和：

```assembly
AddTwo PROC,
	vall:DWORD,
	val2:DWORD
	mov eax,vall
	add	eax,va12
	ret
AddTwo FNDP
```

汇编AddTwo时生成的汇编语言代码显示了参数名是如何翻译成相对于EBP的偏移的，由于使用的是STDCALL调用约定，MASM还为RET指令生成了一个常量操作数：

```assembly
AddIwo PROC
	push ebp
	mov	 ebp,esp
	mov  eax,dword ptr [ebp+8]
	add  eax,dword ptr [ebp+0Ch]
	leave
	ret 8
AddTwo ENDP
```

提示：MASM生成的代码的完整细节在列表文件中（.LST扩展伪指令）是没有的，可使用调试器打开程序，然后查看反汇编窗口中该过程的代码。

### 例子2

下面的FillArray过程接收一个指向字节数组的指针：

```assembly
FillArray PROC,
	pArray:PTR BYTE
	...
FillArray ENDP
```

### 例子3

下面的Swap过程接收两个指向双字的指针：

```assembly
Swap PROC,
	pValX:PTR DWORD,
	pValY:PTR DWORD
Swap ENDP
```

### 例子4

下面的Read_File过程接收一个指向字节的指针pBuffer,该过程有一个双字类型的
局部变量fileHandle,并在堆栈上保存了两个寄存器：

```assembly
Read_File PROC USES eax ebx,
	pBuffer:PTRBYTE
	LOCAL fileHandle:DWORD
	
	mov esi,pBuffer
	mov fileHandle,eax
	
	ret
Read_File ENDP
```

MASM为Read_File过程生成的代码如下所示，代码显示了MASM是如何在（USES操作符指定的）EAX和EBX压栈之前为堆栈上的局部变量(fileHandle)保留空间的：

```assembly
Read_File PROC
	push ebp
	mov  ebp,esp
	add  esp,0FFFFFFFCh	;创建fileHandle
	push eax			;保存EAX
	push ebx			;保存EBX
	
	mov  esi,word ptr [ebp+8]	; pBuffer
	mov  dword ptr [ebp-4],eax	; fileHandle
	
	popebx
	pop eax
	leave
	ret 4
Read_File ENDP
```

### ==PROC对RET指令的修改==

==PROC伪指令在默认使用STDCALL调用约定并带一个或多个参数时，假设过程有n个参数，MASM将为其生成如下入口和退出代码：==

```assembly
	push ebp
	mov  ebp,esp
	
	leave
	ret  (n*4)
```

RET指令之后的常量等于参数的数目乘以4(每个参数都是双字）。在包含Irvine32.inc文件时，STDCALL调用约定是默认的，STDCALL也是（几乎）所有的Windows API函数使用的调用约定。

### 指定参数传递约定（协议）

一个程序有可能既调用Irvine32库又包含了要由C++程序调用的过程。为提供这种灵活性，PROC伪指令的属性域允许指定参数传递的语言约定，PROC中的语言约定会覆盖.MODEL伪指令指定的默认的语言约定。下面的例子声明了一个使用C调用约定的过程：

```assembly
Example1 PROC C,
	parm1:DWORD,parm2:DWORD
```

如果使用INVOKE调用过程Example1,汇编器生成的代码将遵循C调用约定。类似地，如果使用STDCALL声明Example1，MASM将为INVOKE生成遵循STDCALL约定的代码：

```assembly
Example1 PROC STDCALL,
	parml:DWORD,parm2:DWORD
```

## 8.5.4 PROTO伪指令

==PROTO伪指令为一个已存在的过程创建一个原型（prototype)。原型声明了过程的名字和参数列表，它允许在定义过程之前就调用该过程并验证调用时传递的参数的类型和数目是否与定义相匹配（C/C++语言在编译时使用函数原型来验证函数调用）。==
MASM要求INVOKE调用的过程要有合适的原型声明。在一种情况下，PROTO必须出现在
INVOKE指令之前，换句话说，这些伪指令使用的标准次序如下：

```assembly
MySub PROTO		;过程原型
INVOKE MySub	;过程调用
MySub PROC		;过程实现
.
MySub ENDP
```

另一种情况也是可能出现的：过程的实现在INVOKE语句调用过程之前出现，在这种情况下，PROC本身就起到了原型的作用：

```assembly
MySub PROC	;过程实现
MySub ENDP
INVOKE MySub	;过程调用
```

如果已经编写了某个特定的过程，为它创建原型就很简单了，只需复制PROC所在行语句并做如下修改：

- 把PROC改为PROTO。
- 如果有USES伪指令，去掉USES伪指令以及其后的寄存器列表。

```assembly
ArraySum PROC USES esi ecx,
	ptrArray:PTR DWORD,	;指向数组
	SZArray:DWORD
	;数组的大小
	;(其余行省略）
ArraySum ENDP
```

下面是对应的原型声明：

```assembly
ArraySum PROTO,
	ptrArray:PTR DWORD,	;指向数组
	szArray:DWORD
	;数组的大小
```

PROTO伪指令能替换.MODEL伪指令中的默认参数传递约定。它必须与过程中的声明一致：

```assembly
Examplel PROTO C
	parm1:DWORD,parm2:DWORD
```

### 汇编时的参数检查

PROTO伪指令可以帮助汇编器对比过程定义和过程调用的参数列表是否一致。汇编器的参数检查不如C/C++严格，MASM检查过程调用的参数的数目是否正确，并对参数的类型进行有限的匹配检查。假设过程Sub1的原型声明如下：

```assembly
Sub1 PROTO, p1: BYTE, p2: WORD, p3: PTR BYTE
```

我们定义如下的变量：

```assembly
data
	byte_1 BYTE 10h
	word_1 WORD 2000h
	word_2WORD3000h
	dword_1 DWORD 12345678h
```

下面是有效的调用：

```assembly
INVOKE Sub1, byte_1, word_1, ADDR byte_1
```

MASM为这条INVOKE语句生成的代码表明参数是按与指令的参数列表相反的顺序压栈的：

```assembly
push 	404000h		;byte_1的指针
sub 	esp,2		;以2字节填充堆栈
push 	word ptr ds:[00404001h]	;word_1的值
mov 	al,byte ptr ds:[00404000h];byte_1的值
push 	eax
call	00401071
```

EAX被改写了.subesp,2把下一个堆栈项填充到32位。

### MASM检测到的错误

如果实际参数超过了声明参数的尺寸大小.MASM就会产生一个错误：

```assembly
INVOKE Sub1,word_1,word_2,ADDR byte_1	;参数1错误
```

如果调用Sub1时传递的参数过少或过多，MASM也会产生错误：

```assembly
INVOKE Sub1,byte_1,word_2		;参数过少
INVOKE Sub1,byte_1,word_2,ADDR byte_1,word_2;参数过多
```

MASM检测不到的错误：如果实际参数的尺寸小于声明的参数的尺寸，MASM不会产生错误：

```assembly
INVOKE Sub1, byte_1, byte_1, ADDR byte_1
```

相反，MASM会把传递的较小的参数扩展到声明参数的尺寸大小。在下例中，MASM为上面的INVOKE例子生成的代码中，第二个参数（byte_1)在压入堆栈之前扩展至EAX,然后再把EAX压栈：

```assembly
push 	404000h	;byte_1的地址
mov 	al,byte ptr ds:[00404000h];byte_1的值
movzx 	eax,al	;扩展至EAX
push 	eax		;压栈
mov 	al,byte ptr ds:[00404000h];byte_1的值
push 	eax		;压栈
call 	00401071	;调用Sub1
```

在期望使用指针的时候传递了双字，MASM则不会检测到错误。在子过程试图以堆栈参数作为指针使用时通常会在运行时导致错误：

```assembly
INYOKE Sub1, byte_1, word_2, dword_1;未检查到错误
```

### 例子ArraySum

前面第5章中的例子ArraySum计算一个双字数组之和。在前面的版本中，使用寄存器传递参数，现在可以使用PROC伪指令声明堆栈参数了：

```assembly
ArraySum PROC USES esi ecx,
			ptrArray:PTR DWORD,	;指向数组
			szArray:DWORD		;数组的大小
	mov esi,ptrArray			;数组的地址
	mov ecx,szArray			;数组的大小
	mov eax,0				;和设为
	cmp ecx,0				;长度等于0?
	je 	L2					;是：退出
L1:
	add eax,[esi]			;每个整数都与和相加
	add esi,4				;指向下一个整数
	loop L1					;按数组的大小重复
L2:
	ret						;和在EAX中
ArraySum ENDP
```

INVOKE语句调用ArraySum,向过程传递了数组的地址以及数组中元素的数目：

```assembly
.data
	array DWORD 10000h,20000h,30000h,40000h,50000h
	theSum DWORD ?
.code
main PROC
	INVOKE ArraySum,
	ADDR array,			;Array的地址
		LENGTHOF array	;元素的数目
	mov theSum,eax		;存储和
```

## 8.5.5 参数分类

> 输入参数是实参是一个值，不期望子过程对值进行处理，就算处理都仅限于过程内
>
> 输出参数是实参是一个引用，期望子过程对引用的对象进行处理
>
> 输入输出参数是，子过程即期望参数包含值，也期望对值进行变更

过程的参数通常依据调用程序和被调用过程之间的数据传输方向进行分类

- **输入参数**：==输入参数是调用程序向被调用过程传递的数据，这时并不期望被调用过程修改对应的变量。即使这样做了，修改也仅局限于过程自身之内。==

- **输出参数**：==输出参数是通过向过程传递一个变量的指针而创建的。过程使用变量的地址定位变量并为变量赋值。==例如Win32控制台库中有一个名为ReadConsole函数从标准输入读取字符串，调用程序向被调用过程传递一个字符串缓冲区的指针，ReadConsole函数把用户输入的字符存储至该缓冲区中：

```assembly
.data
	buffer BYTE 80 DUP(?)
	inputHandle DWORD ?
.code
	INVOKE ReadConsole, inputHandle, ADDR buffer,
	(etc.)
```

- **输入输出参数**：==输入输出参数与输出参数基本等同，只有一点不同：被调用的过程期望参数引用的变量包含某些数据，过程也同时期望通过变量的指针修改变量==。

## 8.5.6 例子：交换两个整数

下面的过程Swap过程交换两个32位整数的内容。过程包含了两个输入输出参数pValX和
pValY,用于存放两个待交换的整数变量的地址。

```assembly
TITLE Swap Procedure Example	(Swap.asm)
INCLUDE Irvine32.inc
Swap PROTO, pValX: PTR DWORD, pValY: PTR DWORD
.data
	Array DWORD 10000h,20000h
.code
main PROC
;Display the array before the exchange:
	mov 	esi,OFFSET Array
	mov 	ecx,2		; count 2
	mov	 	ebx,TYPE Array
	call 	DumpMem		; dump the array values
	INVOKE 	Swap,ADDR Array, ADDR [Array+4]
;Display the array after the exchange:
	call DumpMem
	exit
main ENDP
Swap PROC USES eax esi edi,
		pValX:PTR DWORD,		;pointer to first integer
		pValY:PTR DWORD			; pointer to second integer
; Exchange the values of two 32-bit integers
; Returns : nothing
		mov 	esi,pValx		; get pointers
		mov 	edi,pValy
		mov 	eax,[esi]		; get first integer
		xchg 	eax,[edi]		; exchange with second
		mov 	[esi],eax		; replace first integer
		ret
;PROC generates RET 8 here
		Swap ENDP
END 	main
```

Swap过程的两个参数pValX和pValY都是输入输出参数，它们的当前值对过程而言是输入，过程修改后返回的新值通过这两个参数输出。由于我们使用的是带参数的PROC伪指令，汇编器将把过程结束处的RET指令修改为RET8(假设使用STDCALL调用约定）。

## 8.5.7 调试疑难提示

本节的目的在于使读者注意几类在汇编语言中向过程传递参数时常遇到的错误，希望读者不要不要犯这样的错误。

### 参数尺寸不匹配

数组元素的地址是基于数组元素的大小计算的，因此如果使用数组元素的地址的话，一定要记住，地址要根据数组元素的大小进行调整。为了寻址双字数组的第二个元素，就应该在数组的起始地址上加4。假设要调用8.5.6节的Swap过程，向过程传递DoubleArray的前两个元素的指针，如果把第二个元素的地址计算为DoubleArray+1,那么在调用Swap之后DoubleArray中前两个元素的十六进制数值就是错误的：

```assembly
.data
DoubleArray DWORD 10000h, 20000h
.code
INVOKE Swap, ADDR [DoubleArray + 0], ADDR [DoubleArray + 1]
```

### 传递错误类型的指针

使用INVOKE时，记住编译器并不验证传递给过程的指针类型，例如，8.5.6节的Swap过程接收两个指向双字的指针，如果由于疏忽传递了指向字节的指针：

```assembly
.data
ByteArray BYTE 10h, 20h, 30h, 40h, 50h, 60h, 70h, 80h
.code
INVOKE Swap, ADDR [ByteArray + 0], ADDR [ByteArray + 1]
```

程序可以通过编译并运行，在使用ESI和EDI寻址的时候，两个32位的值被交换了。

### 传递立即数

如果程序有一个传递引用的参数，就不能对这个参数传递立即数。考虑下面的过程，它使用一个传递引用的参数：

```assembly
Sub2 PROC dataPtr : PTR WORD
	mov esi,dataptr		;获取地址
	mov [esi],0			;寻址，赋0
	ret
Sub2 ENDP
```

下面的INVOKE语句能通过编译但会导致一个运行时错误，因为Sub2过程接收1000h后会以其作为指针去寻址内存地址1000h处的值：

```assembly
INVOKE Sub2, 1000h
```

这个例子有可能会导致一个通用保护错误，因为内存位置1000h并不在程序的数据段内。

# 8.6 创建多模块程序

非常大的源码文件难于管理并且汇编起来也很慢。可以把一个文件分成多个包含文件，但是对任何原文的修改仍然要汇编所有的文件。一种较好的方法是把程序分解成模块（module或assemble unit,汇编单位）。每个模块都单独汇编，对一个模块源码的修改只需重新汇编那个模块即可，连接器可以相当迅速地把所有汇编模块（OBJ文件）链接成一个可执行文件。==链接多个目标代码模块要比汇编同样数量的源代码文件快得多创建多模块程序时有两种常用的方法：第一种方法是使用传统的EXTERN伪指令，在不同的80x86汇编器之间移植可能会有些问题。第二种方法是使用MASM的高级INVOKE和PROT伪指令，这些伪指令简化了调用并隐藏了一些底层细节。==本书对两种方法都进行了阐述，读者可自行决定采用何种方法。

## 8.6.1 过程名的隐藏和导出

==默认情况下，MASM使得所有的过程名都成为公共名字，这使得同一程序的其他任何模块都可以调用这些过程。可通过使用PRIVATE修饰符来改写这种默认行为==：

```assembly
mySub PROC PRIVATE
```

通过使得名字私有，就可以应用封装的原则在模块内隐藏过程名并避免在其他模块使用同样名字的过程时发生冲突。

### OPTION PROC:PRIVATE伪指令

在源码模块中隐藏过程的另外一种方法就是在文件的头部放置伪指令`OPTION PROC:PRIVATE,`这时默认所有的过程都变成私有的了，可以使PUBLIC 伪指令指定任何要导出的过程：

```assembly
OPTION PROC:PRIVATE
PUBLIC mySub
```

PUBLIC伪指令后跟一个以逗号分隔的名字列表：

```assembly
PUBLIC sub1, sub2, sub3
```

此外还可以在声明过程时把过程声明为PUBLIC过程：

```assembly
mySub PROC PUBLIC
...
mySub ENDP
```

如果在程序的启动模块中使用`OPTION PROC:PRIVATE`伪指令，一定要使启动过程（通常是 main)成为PUBLIC的，否则操作系统加载器将无法找到入口。例如：

```assembly
main PROC PUBLIC
```

## 8.6.2 调用外部过程

==EXTERN伪指令用于在调用当前模块之外的过程时使用，它可以指定外部过程的名字和外部过程堆栈框架的大小==。下面的例子调用了位于外部模块的过程sub1:

```assembly
INCLUDE Irvine32.inc
EXTERN sub1@0:PROC
main PROC
	call sub1@0
	exit
	main ENDP
END main
```

==当汇编器发现CALL指令调用的过程在源码文件中不存在时，其默认行为是产生一个错误不过如果使用了EXTERN伪指令的话，EXTERN伪指令会通知汇编器为该过程创建一个空白的地址项，链接器在创建整个可执行文件时负责解析并修正该空白地址。==
过程名后的@n后缀指明了参数使用的总的堆栈空间（参见8.5节对扩展的PROC伪指令的说明）。如果使用的基本的PROC伪指令声明中没有参数，那么EXTERN伪指令中每个过程名后后缀就应该是@0。如果声明过程时使用的是带参数的扩展的PROC伪指令，那么对于每个参数@后的数值要加4。假设声明AddTwo带两个双字参数：

```assembly
AddTwo PROC,
	Va12:DWORD,
AddTWO ENDP
```

==对应的EXTERN伪指令就应该是：EXTERNAddTwo@8:PROC。如果想要使用INVOKE伪指令调用AddTwo(参见8.5节）,那么应该在使用EXTERN伪指令的地方使用PROTO伪指令：==

```
AddTwo PROTO,
	val1:DWORD
	va12:DWORD
```

## 8.6.3 跨越模块的边界使用变量和符号

### 导出变量和符号

变量和符号默认对于其所在的模块而言是私有的。可以使用PUBLIC伪指令导出特定的名字，如下例所示：

```assembly
PUBLIC count,SYM1
SYM1=10
.data
count DWORD 0
```

### 访问外部变量和符号

可以使用EXTERN伪指令访问外部模块定义的符号和变量：

```assembly
EXTERN 	name : type
```

对于符号而言（以EQU和“=”定义的）,type应该是ABS;对于变量而言，type应该是数据定义属性，如BYTE,WORD,DWORD,SDWORD以及PTR。下面是一些例子：

```assembly
EXTERN one : WORD , two : SDWORD , three : PTR BYTE , four : ABS
```

### 使用包含EXTERNDEF伪指令的包含文件

MASM有一个非常有用的操作符可替代PUBLIC和EXTERN,该伪指令可放在一个文本件中，使用INCLUDE伪指令包含进每个程序模块中。例如定义一个名为vars.inc的文件，包含如下的声明：

```assembly
; vars.inc
EXTERNDEF count:DWORD,SYM1:ABS
```

接下来创建一个文件subl.asm,该文件包含count和SYM1的定义，使用INCLUDE伪指令包含vars.inc文件：

```assembly
TITLE sub1.asm
.386
.model flat,STDCALL
INCLUDE vars.inc
SYM1 = 10
.data
	count DWORD 0
END
```

由于这不是程序的启动模块，我们在END伪指令后省略了程序的入口标号，也无须声明运行时栈。
接下来，创建一个启动模块main.asm,它包含vars.inc文件并引用了count和SYM1:

```assembly
TITLE main.asm
INCLUDE Irvine32.inc
INCLUDE vars . inc
.code
	main PROC
	mov  count,2000h
	mov  eax, SYM1
	exit
	main ENDP
END main
```

该模块也不包含运行时栈的声明，运行时栈是在Irvine32.inc中用.STACK伪指令声明的，模块在END伪指令后定义了程序的入口点。

## 8.6.4例子：ArraySum程序

在第5章中首次给出的AraySum过程是一个很容易分解成模块的简单程序。为快速回顾一下程序的设计，请看图8.10的结构图，加了阴影的方框表示引用的是本书链接库中的过程。main过程调用了PromptForIntegers,后者又调用了WriteString和ReadInt。一般而言，创建一个单独的磁盘目录保存多模块程序的源文件有助于跟踪这些文件，这也正是我们处理ArraySum程序时的做法，如下节所示。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.ljf51b19h0g.webp)

## 8.6.5 使用ENTERN创建模块

对于多模块的ArraySum程序，本书给出两个版本。本节使用传统的EXTERN伪指令引用单独模块内的函数，在后面的8.6.6节，将使用高级伪指令INVOKE,PROTO和PROC实现同样的程序。
PromptForlntegers:模块_prompt.asm包含了PromptForlntegers过程的源码。该过程提示用户输入三个整数，调用ReadInt读取输入，然后把值插入到数组中。

```assembly
TITLE Prompt For Integers	(_prompt.asm)
INCLUDE Irvine32.inc
.code
PromptForIntegers PROC
; Prompts the user for an array of integers and fills
; the array with the user's input.
; Receives :
	ptrPrompt:PTR BYTE		; prompt string
	ptrArray: PTR DWORD		; pointer to array
	arraySize:DWORD			; size of the array
; Returns : nothing
	arraySize 	EQU [ebp+16]
	ptrArray 	EQU [ebp+12]
	ptrPrompt 	EQU [ebp+8]
	enter 0,0
	pushad					; save all registers
	mov ecx,arraySize
	cmp ecx,0				; array size < = 0 ?
	jle L2					; yes:quit
	mov edx,ptrPrompt		; address of the prompt
	mov esi,ptrArray
L1:
	call WriteString		; display string
	call ReadInt			; read integer into EAX
	call Crlf				; go to next output line
	mov [esi],eax			; store in array
	add esi,4				; next integer
	loopL1
L2:	
	popad					; restore all registers
	leave
	ret 12					; restore the stack
PromptForIntegers ENDP
END
```

#### ArraySum

模块_arraysum.asm包含了ArraySum过程的，该过程计算数组元素的和并在EAX中返回：

```assembly
TITLE ArraySum Procedure	(_arrysum.asm)
INCLUDE Irvine32.inc
.code
ArraySum PROC
; Calculates the sum of an array of 32-bit integers.
; Receives :
; ptrArray
; pointer to array
; arraySize
; size of array (DWORD)
; Returns : EAX = sum
	ptrArray  EQU [ebp+8]
	arraySize EQU [ebp+12]
	enter 	0,0
	push  	ecx			; don't push EAX
	push  	esi
	mov   	eax,0			; set the sum to zero
	mov   	esi,ptrArray
	mov   	ecx,arraySize
	cmp   	ecx,0			; array size < = 0?
	jle 	L2				;yes:quit
L1: 
	add 	eax,[esi]		; add each integer to sum
	add 	esi,4			; point to next integer
	loop 	L1				; repeat for array size
L2:
	pop		esi
	pop		ecx				; return sum in EAX
	leave
	ret 8					; restore the stack
ArraySum ENDP
END
```

### DisplayNum

模块_display.asm包含了DisplaySum过程，该过程显示一个标号，后跟数组之和：

```assembly
TITLE DisplaySum Procedure (_display.asm)
INCLUDE Irvine32.inc
.code
DisplaySum PROC
; Displays the sum on the console .
; Receives :
; ptrPrompt
; offset of prompt string
; theSum
; the array sum (DWORD)
; Returns : nothing
	theSum 		EQU [ebp+12]
	ptrPrompt 	EQU [ebp+8]
	enter  		0,0
	push 	eax
	push 	edx
	mov 	edx,ptrPrompt		; pointer to prompt
	call 	WriteString
	mov 	eax,theSum
	call 	WriteInt			; display EAX
	call 	Crlf
	pop 	edx
	pop 	eax
	leave
    ret 	8					; restore the stack
DisplaySum ENDP
END
```

### 启动模块

模块Sum_main.asm包含了启动过程（main),该模块包含了三个外部过程的EXTERN声明。为使源码更加可读，使用EQU伪指令重新定义了过程的名字：

```assembly
ArraySum			EQU ArraySum@0
PromptForIntegers	EQU PromptForIntegers@0
DisplaySum			EQU DisplaySum@0
```

在每个过程调用之前，使用一条注释描述参数的顺序，该程序使用的参数传递约定是STDCALL:

```assembly
TITLE Integer Summation Program (Sum_main.asm)
; Multimodule example :
; This program inputs multiple integers from the user,
; stores them in an array, calculates the sum of the
; array , and displays the sum .
INCLUDE Irvine32.inc
	EXTERN PromptForIntegers@0:PROC
	EXTERN ArraySum@0:PROC,DisplaySum@O:PROC
; Redefine external symbols for convenience
ArraySum			EQU ArraySum@
PromptForIntegers 	EQU PromptForIntegers@0
DisplaySum			EQU DisplaySum@0
; modify Count to change the size of the array :
Count = 3
.data
	prompt1 BYTE "Enter a signed integer:",0
	prompt2 BYTE "The sum of the integers is:",0
	array 	DWORD Count DUP(?)
	sum 	DWORD ?
.code
main PROC
	call Clrscr	; PromptForIntegers( addr prompt1, addr array, Count)
	push Count
	push OFFSET array
	push OFFSET prompt1
	call PromptForIntegers		;sum=ArraySum(addr array,Count)
	push Count
	push OFFSET array
	call ArraySum
	mov sum,eax				; DisplaySum ( addr prompt 2 , sum )
	push sum
	push OFFSET prompt2
	call DisplaySum
	call Crlf
	exit
main ENDP
END main
```

这个程序的源码文件存储在例子程序目录ch08\ModSum32_traditional之下。

## 8.6.6 使用INVOKE和PROTO创建模块

多模块程序可以使用MASM的高级伪指令INVOKE,PROTO和扩展PROC伪指令（参见8.5节）创建。与使用CALL和EXTERN的传统方法相比，其主要优点在于能够匹配INVOKE伪指令中传递的参数列表和PROC伪指令声明的参数列表并检查是否一致。
创建ArraySum程序的第一步是创建一个包含了每个外部过程的PROTO伪指令声明的包含文件，每个模块都将包含该文件（使用INCLUDE伪指令）,这不会带来任何代码尺寸以及运行时的开销。如果某个模块没有调用特定的过程，那么对应的PROTO伪指令就会被汇编器忽略。这个程序的源码文件存储在例子程序目录ch08\ModSum32_advanced下。

### sum.inc包含文件：

下面是sum.inc包含文件的内容：

```assembly
;(sum.inc)
INCLUDE Irvine32.inc
PromptForIntegers PROTO,
	ptrPrompt:PTR BYTE,		; prompt string
	ptrArray:PTR DWORD,		; points to the array
	arraySize:DWORD			; size of the array
ArraySum PROTO,
	ptrArray:PTR DWORD,		; points to the array
	count:DWORD				; size of the array
DisplaySum PROTO,
	ptrPrompt:PTR BYTE,		; prompt string
	theSum:DWORD			; sum of the array
```

### \_prompt模块

文件\_prompt.asm使用PROC伪指令声明PromptForIntegers所需的参数，该文件还用INCLUDE把sum.inc复制到该文件中来：

```assembly
TITLE Prompt For Integers	(_prompt.asm)
INCLUDE sum.inc
; get procedure prototypes
.code
PromptForIntegers PROC,
		ptrPrompt:PTR BYTE,		; prompt string
		ptrArray:PTR DWORD,		; pointer to array
		arraySize:DWORD
; size of the array
; Prompts the user for an array of integers and fills
; the array with the user's input.
; Returns : nothing
		pushad					; save all registers
		mov ecx,arraySize
		cmp ecx,0				; array size < = 0?
		jle L2					;yes:quit
		mov edx,ptrPrompt		; address of the prompt
		mov esi,ptrArray
L1: 
		call WriteString		; display string
		call ReadInt			; read integer into EAX
		call Crlf				; go to next output line
		mov [esi],eax			; store in array
		add esi,4				; next integer
		loop L1
L2:
		popad					; restore all registers
		ret
PromptForIntegers ENDP
END
```

与以前版本的PromptForIntegers相比，语句enter0,0和leave不见了，MASM在遇到声明了参数的PROC伪指令时会生成这些指令；RET指令也无须带常量参数了（PROC会处理这些）。

### \_arraysum模块

接下来，_arraysum.asm包含了ArraySum过程：

```assembly
TITLE ArraySum Procedure	(_arrysum.asm)
INCLUDE sum.inc
.code
ArraySum PROC,
	ptrArray:PTR DWORD,		; pointer to array
	arraySize:DWORD
; size of array
; Calculates the sum of an array of 32-bit integers.
; Returns:EAX=sum
	push ecx				; don't push EAX
	push esi
	mov eax,0				; set the sum to zero
	mov esi,ptrArray
	mov ecx,arraySize
	cmp ecx,0				; array size < = 0?
	jle L2					; yes : quit
L1:
	add eax,[esi]			; add each integer to sum
	add esi,4				; point to next integer
	loop L1					; repeat for array size
L2:
	pop esi
	pop ecx					; return sum in EAX
ArraySum ENDP
END
```

### _display模块：

文件\_display.asm包含了DisplaySum过程：

```assembly
TITLE DisplaySum Procedure (_display.asm)
INCLUDE Sum.inc
.code
DisplaySum PROC,
	ptrPrompt:PTR BYTE,		; prompt string
	theSum:DWORD			; the array sum
; Displays the sum on the console .
; Returns : nothing
	push eax
	push edx
	mov edx,ptrPrompt		; pointer to prompt
	call WriteString
	mov eax,theSum
	call WriteInt			; display EAX
	call Crlf
	pop edx
	pop eax
	ret
DisplaySum ENDP
END
```

### Sum_main模块：

Sum_main.asm(启动模块）包含了启动过程main和对每个外部过程的调用，该文件使用了INCLUDE伪指令从sum.inc文件中复制过程原型：

```assembly
TITLE Integer Summation Program (Sum_main.asm)
INCLUDE sum.inc
Count = 3
.data
	prompt1 BYTE "Enter a signed integer:",0
	prompt2 BYTE "The sum of the integers is:",0
	array DWORD Count DUP(?)
	sum DWORD ?
.code
main PROC
	call 	Clrscr
	INVOKE 	PromptForIntegers,ADDR prompt1,ADDR array,Count
	INVOKE 	ArraySum,ADDR array,Count
	mov 	sum,eax
	INVOKE 	DisplaySum,ADDR prompt2,sum
	call 	Crlf
	exit
main ENDP
END main
```

==小结：前面已经给出了创建多模块程序的两种方法第一种方法是使用传统的EXTERN伪指令的方式；第二种方法是使用高级伪指令INVOKE,PROTO和PROC。这些伪指令简化了很多细节，还专门针对Windows API函数调用进行了优化。由于第二种方法隐藏了大量的细节，因此读者可能更喜欢使用第一种方法：使用CALL,EXTERN以及显式的堆栈参数。==

# 8.7本章小结

==有两种基本类型的过程参数：寄存器参数和堆栈参数==。Irvine32和Irvine16库使用寄存器参数，这两个库专门针对程序执行速度进行了优化。但遗憾的是，这有可能会造成调用代码的混乱。==堆栈参数是另外一种选择，被调用过程的参数必须由调用过程压栈。==
==堆栈框架（stack frame)也称活动记录（activation record),它是为传递的参数、子例程的返回地址、局部变量和保存的寄存器保留的堆栈空间。一个过程的堆栈框架是在运行的程序开始执行该过程时创建的==
==通过在堆栈上压人变量值的一份复制的方式传递参数，就称为传递值（pass by value),或简称为传值。一个地址被作为参数压入堆栈，就是通过引用传递的，过程可以通过地址修改变量数组应通过引用传递，以避免把所有元素全部压栈==
==过程的参数可以使用EBP间接寻址访问。LEA指令返回任何间接操作数的偏移地址，LEA指令非常适合用于堆栈操作数。==
==ENTER指令通过在栈上保存EBP的值并为局部变量保留空间创建堆栈框架。LEAVE指令通过反转ENTER指令的动作释放堆栈框架。==
递归过程是通过直接或间接的方式调用自身的过程，当操作有某种重复模式的数据结构时，递归可能是非常强大的工具。
==LOCAL伪指令在过程内声明一个或多个命名局部变量。语句必须紧接在PROC伪指令所在行之后==。局部变量与全局声明的变量相比有明显的优点：

- 只有在局部变量所在过程之内的语句才能够看到和修改局部变量。这个特点有助于避免程序源码中多处修改一个变量导致的bug
- 局部变量使用的存储空间在过程结束后即释放。
- 一个过程内的局部变量的名字可以和其他过程内的局部变量名相同，不会发生名字冲突。这个特性对于大程序是非常有用的，在大程序中，变量名相同的可能性还是比较大的。
- 对递归过程以及可能由多个线程同时执行的过程而言，局部变量是必需的。

==INVOKE伪指令是比Intel的CALL指令功能更为强大的替代品，它允许传递多个参数。使用INVOKE伪指令调用过程时可以使用ADDR来传递指针==
==PROC伪指令声明了一个过程及其参数列表。PROTO伪指令为已存在的过程创建原型。原型声明了过程的名字和参数列表==
==MASM使用.MODEL伪指令决定程序的几个重要特性：内存模式的类型、函数命名方案和参数传递的约定。==本书中到现在为止的实地址模式程序使用的都是小内存模式，也就是说程序的代玛放在一个单独的代码段中，数据（包括堆栈）放在另一个单独的段中。==保护模式程序使用平坦内存模式，在该模式下所有的偏移都是32位的，代码段和数据段最大可达4GB。最常用的语言关键字是C和STDCALL==。
一个应用程序，无论大小，当所有代码都在同一个源文件中时很难管理和维护，把程序分成多个源代码文件（称为模块）更加方便，这样每个文件都易于查看和编辑。