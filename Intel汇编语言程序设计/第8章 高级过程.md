[toc]

本章要点
·简介
·堆栈框架
·递归
·MODEL伪指令
·INVOKE,ADDR,PROC和PROTO伪指令（可选）
·创建多模块程序

# 8.1简介

本章着重讲述子例程和子例程调用的工作机制。探究使学习更加轻松的通用概念是很自然的一种倾向，因此本章以汇编语言作为低阶的编程工具，讲述过程的基本工作机制。换句话说，本章的内容也经常在C++和Java的中级程序设计课程，或者在名为程序设计语言的核心计算机科学课程上进行讲述。本章中讨论的下列主题是最基本的程序设计语言概念：

- ·堆栈框架
- ·变量的作用域和生存期
- ·堆栈参数的类型
- ·通过传递值或者传递引用来传递参数
- ·在堆栈上创建和初始化局部变量
- ·递归
- ·编写多模块的程序
- ·内存模型和语言关键字

本章部分选学的内容对MASM中的一些高级伪指令进行了介绍，这些伪指令是为方便应用程序员而设计的：

- ·INVOKE,PROC和PROTO伪指令
- ·USES和ADDR操作符

以上的汇编语言知识使你能够窥测编译器作者生成可执行程序代码的方法。
关于术语的注记：对于子例程（subroutine),不同的程序设计语言通常使用不同的术语。在C/C++中，称子例程为函数（function);在Java中，称子例程为方法（method);在MASM中称子例程为过程（procedure)。本章的重点在于讲述（C/C++中的）典型的子例程调用的底层实现。在本章开始部分讲述一般性的原则的时候，使用术语“子例程”；在本章后面讲述特定的MASMz伪指令（如PROC和PROTO)时，则使用特定的术语“过程”。

# 8.2堆栈框架

堆栈框架（stack frame)也称活动记录（activation record),它是为传递的参数、子例程的返回地址、局部变量和保存的寄存器保留的堆栈空间。堆栈框架是按以下步骤创建的：

- ·如果有传递的参数，则压入堆栈
- ·子例程被调用，子例程的返回地址压入堆栈。
- 子例程开始执行时，EBP被压入堆栈。
- EBP设为ESP的值，从这时开始，EBP就被作为寻址所有子例程参数的基址指针使用了
- 如果有局部变量，ESP减去一个数值，以便在堆栈上为局部变量保留空间。
- 如果任何寄存器需要保存，则压入堆栈。

堆栈框架的结构受程序的内存模式以及参数传递约定的直接影响。
学习通过堆栈传递参数的理由很充分：几乎所有的高级语言都使用堆栈传递参数。例如，如果想要调用MS-Windows的应用编程接口（API),就必须通过堆栈传递参数。

## 8.2.1堆栈参数

有两种基本类型的子例程参数：寄存器参数和堆栈参数。Irvine32和Irvine16库使用寄存器参数，本节讲述如何声明和使用堆栈参数
调用程序向子例程传递的值称为argument(参数）,当这些值被子例程接收的时候，它们被称为parameter(参数）
被调用的子例程访问调用子例程时压入堆栈的参数。使用寄存器参数可以优化程序的执行速度，但遗憾的是，这有可能会造成调用代码的混乱，因为有些寄存器在装入参数之前必须首先保存例如，调用DumpMem时就是这种情况：

```
pushad
mov esi,OFFSET array
起始偏移地址
mov ecx, LENGTHOF array
mov ebx, TYPE array
call DumpMem
```

另外一种更灵活的方法是堆栈参数，在调用子例程之前，参数首先压入堆栈。例如，假设DumpMem使用堆栈参数，那么可以使用下面的代码进行调用：

```
push TYPE arra
push LENGTHOF array
push OFFSET array
call DumpMer
```

在进行子例程调用时在堆栈上压入了两类参数：

- ·值参数（变量和常量的值）
- ·引用参数（变量的地址）

### 传递值：

通过在堆栈上压人变量值的一份副本的方式传递参数，就称为传递值pass by value),或简称为传值。假设要调用一个子例程AddTwo,向该过程传递两个32位整数：

```
.data
vall DWORD 5
Vali DWORD
push val2
push vall
call AddTwo
```

下面是在CALL指令执行之前的堆栈示意图：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.4i55qv1uwb60.webp)

C++中等价的函数调用是：

```
int sum=AddTwo(vall,val2);
```

注意参数在堆栈上是以相反的顺序压栈的，这也是C/C+语言的调用规范。

### 传递引用：

传递引用（pass by reference)的参数是一个对象的地址。下面的语句调用了Swap,
通过引用传递两个参数：

```
push OFFSET val2
push OFFSET vall
call Swap
```

下面是调用Swap前堆栈的示意图：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6z75ba3g1js0.webp)

下面等价的C/C++函数调用传递的是val1和val2的地址：

```
Swap( &va11,&va12);
```

### 传递数组：

前面讲述的传递值的规则有一个例外，那就是在传递数组参数时，高级语言总是传递引用，通过传递值的方式传递大量数据是完全不切实际的，因为传值的方式直接在堆栈上压入数据，这会降低程序的执行速度并用光宝贵的堆栈空间。例如下面的语句向子例程ArrayFill传递array的偏移地址：

```
.data
array DWORD 50 DUP(?)
.code
push OFFSET array
call ArrayFill
```

### 堆栈参数的访问（C/C++)

在调用函数时，C/C++程序使用标准的方法初始化和访问参数。C/C++中的函数以序言(prologue)开始，序言部分的代码保存了EBP寄存器，并使EBP指向当时堆栈的顶部，函数还有可能把一些寄存器压栈，这些寄存器的值将在函数返回的时候恢复。函数以收尾(epilogue)代码结束，在这部分代码中，EBP寄存器被恢复，RET指令从函数返回。
例子AddTwo:下面用C编写的AddTwo函数接收两个整数参数（通过传值的方式传递）并返回其和：

```
int AddTwo( int x, int y)
return x + y;
```

下面给出一个等价的汇编语言实现。在序言部分，AddTwo把EBP压栈以保存其值：

```
AddTwo PROC
push ebp
```

接下来，EBP设为ESP的值，因此EBP可作为AddTwo的堆栈框架的基址指针使用：

```
AddTwo PROC
push ebp
mov ebp , esp
```

在这两条指令执行完后，堆栈框架的内容如下图所示，图中所示堆栈的每个数据项都是双字：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.23y5xto4n0ww.webp)

AddTwo还可以把其他的寄存器压栈，这不会改变堆栈中参数的地址相对于EBP的偏移，随后的代码中，ESP有可能会改变其值，但EBP通常不会。

### 访问堆栈参数：

C/C++函数使用相对基址寻址方式访问堆栈参数，EBP用作基址寄存器，偏移部分是一个常量。函数一般通过EAX返回一个32位的值，下面AddTwo的实现代码把两个堆栈参数相加并在EAX中返回它们的和：

```
AddTwo PROC
push ebp
mov ebp,esp
;堆栈框架的基址
mov eax,[ebp+12]
;第二个参数
add eax,[ebp+8]
;第一个参数
pop ebp
ret
AddTWO ENDP
```

### 堆栈的清理

在子例程返回时，必须要有某种方法清除堆栈上的参数，否则就会导致内存泄露以及堆栈的破坏。假设main中调用AddTwo的语句如下：

```
push 6
push 5
call AddTwo
```

下面是从调用返回后堆栈的示意图：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6i2673hhdfk0.webp)

在main中，我们可以忽略这个问题并期望程序正常结束。不过如果在一个循环中调用AddTwo.堆栈就有可能溢出，因为每次调用都会占用8个字节的堆栈空间。如果Example1调用了AddTwo,main又调用了Example1,那么就会导致更严重的问题：

```
main PROC
ca71 Example1
exit
main ENDP
Example1 PROC
push 5
push 6
call AddTwo
ret
;堆栈被破坏了！
Example1 ENDPExample1中的RET指令返回时，ESP指向5而非main中的返回地址，不用多说你也知道了，
程序转移到地址5执行，这将使程序崩溃。
```

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.43nzmkqf4hc0.webp)

对于这个问题，一种简单的解决方法是在CALL指令后使用一条ADD指令给ESP加上一个值，以使ESP指向正确的返回地址

```
Examplel PROC
push 5
push addT
add esp,8
;从堆栈中移除参数
ret
;堆栈正常了
Example1 ENDP
```

这实际上也就是C/C++程序所使用的方法。

### STDCALL调用约定（Calling Convention):

处理堆栈清理问题的另一种方法是使用STDCAL调用约定，可以在AddTwo过程中的RET指令后提供一个整数参数以修复ESP的值，这个整数值必须等于堆栈参数消耗的堆栈空间字节数。

```
AddTwo PROC
push ebp
mov ebp,esp 121
;堆栈框架的基址
;第一个参效
popebp
ret 8
;清理堆栈
AddTWO ENDP
```

这样一来，上面堆栈清理的问题就简化了：谁应该对清理堆栈负责？是调用子例程的代码，还是子例程本身？这两种方式都有各自的优缺点：STDCALL减少了为子例程调用生成的代码数量（只有一条指令）并且能够确保调用者永远不会忘记清理堆栈；另一方面，C调用约定允许子例程声明可变数目的参数，由调用者决定要传递多少参数。例子之一是printf函数，其参数数目决定于格式化串参数中格式符的数量：

```
intx=5;
floaty=3.2;
printf("Printing values:%d,%f,%c",x,y,z);
```

C编译器在堆栈上按（和参数列表）相反的顺序压入参数，并（通过宏）传递实际参数数目，承数本身（通过宏）获取参数的数目并（通过宏）逐个对参数进行访问。在函数中，由于事先不知道调用者要传递多少个参数，所以没有在RET指令后指定参数占用堆栈空间字节数的便捷方法，清理堆栈的责任只能留给调用者了。

为同MS-Windows API兼容，Irvine32库使用STDCALL调用约定，Irvine16库也使用了同样的调用约定，目的是为了和Irvine32库兼容
从现在开始，除非明确说明，假设所有的例子过程均使用STDCALL调用约定。从现在开始，将使用“过程”一词指代子例程，因为本书几乎所有的例子都是用汇编语言编写的

### 通过堆栈传递8位和16位的参数

在保护模式下传递堆栈参数时，最好使用32位的操作数，虽然可以在堆栈上压入16位的操作数，但这样做会使得ESP无法对齐在双字地址边界上，由此可能会导致发生页故障，程序的性能也可能会降低。因此在传递8位或16位堆栈参数时，应把它扩展到32位再压栈。
下面的Uppercase过程接收一个字符参数并在AL中返回其大写形式：

```
Uppercase PROC
push ebp
mov ebp , esp
;AL=字符
mov al,[esp+8]
cmp al,'a'
;小于'a'
;是：什么也不做
jb L1
cmp al,
;是：什么也不做
subal,32
;否：进行转换
L1:popebp
;清理堆栈
Uppercase ENDP
```

如果向Uppercase传递字符文字量，PUSH指令自动把字符扩展到32位：

```
push 'x
call Uppercase
```

传递字符变量时需要格外小心，因为PUSH指令不允许8位的操作数：

```
.data
charVal BYTE 'x'
.code
push charval
;语法错误
call Uppercase
```

相反，应该使用MOVZX指令把字符值扩展至EAX:

```
movzx eax , charval
;带扩展传送
call Uppercase
```

### 16位参数的例子：

假设要向前面给出的AddTwo过程传递两个16位的整数，由于该过程期
望接收32位参数，因此下面的代码将导致语法错误：

```
data
word1 WORD 1234h
word2 WORD 4111h
.code
push word1
call AddTwo
;错误
```

下面的代码在每个参数压栈之前首先进行零扩展，因此正确地调用了过程AddTwo:

```
movzx eax,word1
push eax
movzx eax , word2
call AddTwo
;和在EAX中
```

过程的调用者必须确保传递的参数和过程期望的参数相一致。就堆栈参数而言，其大小和顺序都是非常重要的！

### 传递长整数参数

在使用堆栈向过程传递长整数（由多个字构成的）参数时，可以先把高位字压栈，然后再把低位字压栈，这样实际上是以小尾顺序（低字节在低地址）把长整数压栈了。下面的WriteHex64过程通过堆栈接收一个64位的整数并以十六进制显示：

```
WriteHex64 PROC
push ebp
mov ebp,esp
mov eax,[ebp+12]
;高双字
call WriteHex
mov eax,[ebp+8]
;低双字
call WriteHex
pop ebp
ret 8
WriteHex64 ENDP
```

下面的例子在调用WriteHex64之前，首先把longVal的高半部分压栈，然后再把低半部分压栈：

```
.data
longVal DQ 1234567800ABCDEFh
.code push DWORD PTR 1ongVal + 4
;高双字
push DWORD PTR longVal
;低双字
call WriteHex64
```

图8.1显示了WriteHex64过程在EBP压栈后的堆栈框架。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.58cqn9apvnk0.webp)

### 保存和恢复寄存器

子过程通常在修改寄存器之前保存其原来的值，以便在过程返回之前进行恢复。理想情况下，要保存的寄存器应在EBP设为ESP的值之后、为局部变量保留空间之前压栈，这有助于避免改变堆栈参数的相对偏移，例如下面的过程MySub有一个堆栈参数，它在把EBP设为ESP的值（以作为堆栈框架的基址指针）之后把ECX和EDX寄存器压栈，然后把堆栈参数装入EAX:

```
MySub PROC
push ebp
;保存基址指针
mov ebp , esp
;堆栈框架的基址
push ecx
push edx
;保存EDX
mov eax,[ebp+8]
;获取堆栈参数
.
pop edx
;恢复已保存的寄存器
popecx

pop ebp
;恢复基址指针
ret
;清理堆栈
MySub ENDP
```

EBP初始化之后，在整个过程内其值保持不变，ECX和EDX的压栈不影响堆栈中的参数相对于EBP的偏移，这是因为堆栈是向下增长的（参见图8.2)。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.2502nf94t534.webp)

### USES 操作符对堆栈的影响

USES操作符（参见第5章）后跟要在过程开始时保存并在过程结束时恢复的寄存器列表，对于列表中的每个寄存器，MASM自动生成合适的PUSH和POP指令。注意：使用显式堆栈参数的过程应避免使用USES操作符。我们来看一下这是为什么，下面的MySub1过程使用了USES操作符保存和恢复ECX及EDX:

```
MySub1 PROC USES ecx edx
ret
MySub1 ENDP
```

下面是汇编MySub1时MASM生成的代码：

```
push ecx
push edx
pop edx
pop ecx
```

假设在MySub2中把USES和堆栈参数一起使用，我们预期第一个参数在堆栈位置EBP+8处：

```
MySub2 PROC USES ecx edx
;保存基址指针
push ebp,esp
:堆栈框架的基址
mov eax,[ebp+8]
;获取堆栈参数
pop ebp
;恢复基址指针
ret 4
;清理堆栈
MySub2 ENDP
```

下面是MASM为MySub2生成的代码：

```
push ecx
push edx
push ebp
mov ebp,esp
mov eax,dword ptr[ebp+8];错误的位置！
pop ebp
pook
ret 4
```

由于MASM在过程的开始插入了PUSH指令，因此改变了堆栈参数相对于EBP的偏移地址，进而导致发生了错误。图8.3表明现在必须通过[EBP+16]引用第一个堆栈参数。与标志的过程序言代码相反，USES操作符在保存EBP之前修改了堆栈。在8.5.3节将看到，PROC伪指令有一种声明堆栈参数的高级语法格式，使用该格式时再使用USES操作符不会发生这样的问题。
使用显式堆栈参数的过程应避免使用USES操作符。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6k7rf9ie1i80.webp)

## 8.2.2局部变量

在高级语言程序中，在单个过程中创建、使用和销毁的变量称为局部变量（local variable)。局部变量与过程之外声明的全局变量相比有明显的优点：

- ,只有在局部变量所在过程之内的语句才能够看到和修改局部变量。这个特点有助于避免程序源码中多处修改一个变量导致的bug。
- ·局部变量使用的存储空间在过程结束后即释放。
- ·一个过程内的局部变量的名字可以和其他过程内的局部变量名相同，不会发生名字冲突。这个特性对于大程序是非常有用的。在大程序中，变量名相同的可能性还是比较大的
- 对递归过程以及可能由多个线程同时执行的过程而言，局部变量是必需的。

局部变量是在运行时栈上创建的。在内存中其位置通常在基址指针（EBP)之下，尽管在汇编时不能给定默认值，但可以在运行时初始化。在汇编语言中创建局部变量时，可以使用和C/C++类似的技术
例子：下面的C++函数声明了局部变量X和Y:

```
void MySub()
{ int X = 10;
} int Y=20;
```

我们以编译后的C++程序为例，看看C++编译器是如何分配局部变量的。每个堆栈项都是32位的双字，因此每个变量的大小是4个字节（按4的倍数向上取整）,程序为这两个变量保留了8个字节的空间。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.6ymynd3hu9s0.webp)

MySub函数的反汇编代码（通过调试器的反汇编窗口查看）展示了C++程序是以何种方式创建局部变量、赋值以及从堆栈上移除变量的，MySub函数使用的是C调用约定：

```
MySub PROC
push ebp
mov ebp , esp
;创建局部变量
sub esp,8
mov DWORD PTR [ebp-4],10 ; X
mov DWORD PTR [ebp-8],20 ;Y
mov esp,ebp
;从堆栈上删除局部变量
pop ebp
ret
MySub ENDP
```

图8.4显示了局部变量初始化之后堆栈框架的情况。

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.2zp8erfe0c80.webp)

在过程返回之前，函数通过把EBP的值赋给ESP恢复了堆栈指针的值，下面的语句的效果相当于从堆栈上释放了局部变量：

```
mov esp,ebp
;从堆栈上删除局部变量
```

如果去掉了上面的语句，POP EBP指令将使得EBP等于10,RET指令导致控制转移到内存地址10处继续执行，最后当然会导致处理器发生异常了。下面是删除了上面的语句的MySub版本：

```
MySub PROC
ebp
moy ebp , esp
sub esp,8
;创建局部变量
mov DWORD PTR [ebp--4],10
;X
mov DWORD PTR [ebp-8],20
;Y
popebp
ret
;返回了到无效地址！
MySub ENDP
```

### 局部变量符号

：为使代码更加易读，可以给每个变量的引用地址都定义一个符号并在代码中
使用这些符号：

```
X local EQU DWORD PTR [ebp-4]
Y_local EQU DWORD PTR [ebp-8]
MySubPROC
push ebp
sub esp
;创建局部变量
mov x local , 10
;X
mov Y_local,20
mov esp,ebp
;从堆栈上删除局部变量
pop ebp
ret
MySub ENDP
```

### 访问引用参数

子过程通常使用相对基址寻址方式访问引用参数，这是由于每个引用参数都是一个指针，实际上引用参数是要被装入到寄存器中作为间接操作数使用的。例如，假设一个指向数组的指针位于堆栈位置[ebp+12]处，下面的语句把该指针复制到ESI中：

```
mov esi,[ebp+12]
;指向数组的指针
```

### 例子：ArrayFill。

下面将要给出的ArrayFill过程，使用16位的随机整数序列填充一个数组。该过程接收两个参数：第一个参数是数组的偏移，第二个参数是指示数组长度的整数。第一个参数通过传递引用方式来传递，第二个参数通过传值方式传递。下面的代码是调用示例：

```
.data
count=100
array WORD count DUP(?)
.code
push OFFSET array
push COUNT
call ArrayFill
```

在ArrayFill过程中，下面的代码初始化了堆栈框架的指针（EBP):

```
ArrayFi11 PROC
push ebp
mov ebp , esp
```

现在堆栈框架如下图所示，其中包含了array的偏移，count,返回地址以及保存的EBP的值：

![image](https://cdn.staticaly.com/gh/YangLuchao/img_host@master/20230301/image.2grnyuf5ily0.webp)

在ArrayFill过程中，首先保存通用寄存器，然后取得参数，最后填充数组：

```
ArrayFi11 PROC
push ebp
mov ebp,esp
pushad
;保存寄存器
mov esi. [ebp+12]
;array的偏移
mov ecx,[ebp+8]
;array的大小
cmpecx,0
;ECX==0?
je L2
;是：跳过循环
L1:
mov ecx,1000h
;获取0~FFFFh之间的随机数
call kandomkange
;来自本书的链接库
mov [esi],ax
;在数组中插入值
add esi, TYPE WORD
;下一个元素
loop L1
L2:popad
;恢复寄存器
pop ebp
ret 8
;清理堆栈
ArrayFill ENDP
```

### LEA 指令

LEA指令返回间接操作数的偏移地址。由于间接操作数可能使用一个或多个寄存器，因此其偏移值是在运行时计算的。为说明LEA指令如何使用，下面首先看一个C++程序的例子，程序声明了一个局部的字节数组myString并在赋值时引用：

```
void makeArray()

char myString[30];
for(inti=0;i-30;i++)
myString[i] ='*';
```

下面等价的汇编代码在堆栈上为myString分配空间并把myString的地址赋予间接操作数ESI,虽然数组只有30个字节，但ESP还是减去了32,以使其按双字边界对齐，注意下面的代码是如何使用LEA指令为ESI赋数组的偏移地址的：

```
makeArray PROC
push ebp
mov ebp,esp
sub esp,32
;myString位于EBP-30
lea esi,[ebp-30]
;加载myString的地址
mov ecx,30
;循环计数器
L1: mov BYTE PTR [esi],'*'
;填充一个位置
incesi
;移到下一个位置
100pL1
;继续循环直到ECX=0
add esp, 32
;删除array(恢复ESP)
pop ebp
ret
makeArray ENDP
```

使用OFFSET操作符获取堆栈参数的地址是不可能的，因为OFFSET只能获取在编译时就已知的地址值。下面的语句汇编时将出错：

```
mov esi, OFFSET [ebp-30]
;错误
```

