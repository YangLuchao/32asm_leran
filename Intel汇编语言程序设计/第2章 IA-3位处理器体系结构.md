[toc]



本章要点·

- 基本概念
- IA-32处理器体系结构
- IA-32的内存管理
- IA-32微机的构成
- 输入输出系统

# 2.1 基本概念

本章以程序员的视角描述IntelIA-32处理器家族及其计算机系统，包括所有的Intel兼容处理器，如AMD的速龙（Athlon)和皓龙（Opteron)处理器。汇编语言是学习计算机如何运行的好工具，同时这也就要求读者具备计算机硬件的相关知识。本章中的概念和细节将有助于读者理解自己编写的汇编语言代码。本章试图在讲述适用于所有微机系统的概念和仅适用于IA-32处理器系列的专有概念之间取得一种平衡。读者将来可能要面对多种不同的处理器，因此本书讲述更加普适的概念。同时为免读者对于体系结构的理解过于肤浅，本书还将着重讲述IA-32系列特有的一些知识，这将为读者使用汇编语言进行程序设计打下坚实的基础。

> 如果读者想要了解更多的关于IA-32体系结构的知识，请阅读Intel的LA-32 Intel ArchitectureSoftware Developer's Manual, Volume 1: Basic Architecture,可以从Intel的网站上免费下载(www.intel.com)。

## 2.1.1微机的基本结构

图2.1展示了一台假想的微型计算机的基本结构。==中央处理器（CPU,Central Processor Unit)是进行所有计算和逻辑操作的地方，它包含了数量有限的称为寄存器（register)的存储单元、一个高频时钟（clock)、一个控制单元（CU,ControlUnit)和一个算术逻辑单元（ALU,Arithmetic Logic Unit)==。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.3rxoe2afgsu0.webp)

- ==时钟用于CPU的内部操作和其他系统部件的同步==。
- ==控制单元（CU)协调执行机器指令时各个步骤的次序==。
- ==算术逻辑单元（ALU)执行加法和减法等算术运算，以及AND,OR和NOT等逻辑运算==。

CPU通过插入主板插槽的引脚同计算机的其余部分相连接，大部分引脚与数据总线、控制总线和地址总线相连接。

==内存存储单元（memory storage unit)是计算机程序运行时存放指令和数据的地方==。内存存储单元接受CPU的数据请求，从随机访问存储器（RAM)中取出数据送至CPU,或把数据从CPU送回存储器中。==总线（bus)是一组用于在计算机各部分之间传送数据的并行线。计算机的系统总线一般由三组独立的总线构成：数据总线、控制总线和地址总线。==数据总线（data bus)在CPU和内存之间传送指令和数据；控制总线（control bus)使用二进制信号同步连接到系统总线上的所有设备的动作；如果当前被执行的指令要在CPU和内存之间传送数据，那么地址总线（address bus)上保持着指令和数据的地址。

时钟：==涉及CPU和系统总线的每个操作都由一个内部时钟同步，这个时钟以固定的频率产生脉冲。机器指令使用的最基本的时间单位称为机器周期（machine cycle)或时钟周期（clock cycletime),也就是一个完整的时钟脉冲所需要的时间==。在下图中，一个时钟脉冲表示为两个下降沿之间的时间间隔：

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.5av150osr540.webp)

时钟周期的持续时间是时钟频率的倒数，时钟频率用每秒振荡的次数来计量。例如，对于每秒振荡10亿次（1GHz)的时钟，其时钟周期的持续时间为1s的10亿分之一（1ns)。

==机器指令的执行至少需要一个时钟周期，有些指令的执行甚至需要超过50个时钟周期（如8088处理器上的乘法指令）==。由于CPU、系统总线和存储电路之间速度的差异，访问内存的指令通常需要称为等待状态（wait state)的空时钟周期（最近的研究表明，在不久的将来，我们或许可以丢弃同步计算模型，取而代之的是不需要系统时钟的异步运算模型）

## 2.1.2 指令执行周期

单条机器指令的执行可以被分解成一系列的独立操作，这些操作构成指令执行的一个周期：程序在开始执行之前必须首先装入内存，指令指针（instruction pointer)包含要执行的下一条指令的地址，指令队列（instruction queue)存放着若干条将要执行的指令。==机器指令的执行需要三个基本步骤：取指令、解码和执行。在指令使用了内存操作数时还需要两个额外的步骤：取操作数和存储输出操作数。==各个步骤的描述如下：

==**取指令**：控制单元从指令队列中取得指令并递增指令指针==（IP)的值，指令指针也称为程序计数器（program counter)。

==解码：控制单元对指令进行解码以确定该指令要执行什么操作==。控制单元把输入操作数传递给算术逻辑单元（ALU),并向算术逻辑单元发送信号指明要执行的操作。

**取操作数**：如果指令使用的输入操作数在内存中，控制单元就通过读操作获取操作数并将其复制到内部寄存器中，这些内部寄存器对用户程序是不可见的。

**执行**：算术逻辑单元执行指令，以有名寄存器和内部寄存器作为操作数，将运算输出结果送至有名寄存器和/或内存，然后更新反映处理器状态的状态标志。

存储输出操作数：如果输出操作数在存储器中，控制单元通过写操作把数据存储到内存中这一系列步骤可用如下的伪码表示：

- 循环开始
	- 取下一条指令
	- 前进指令指针（IP)
	- 如果使用了内存操作数，则从内存读取
	- 执行指令
	- 如果结果是内存操作数，则写入内存
- 继续循环

奔腾（Pentium)处理器的基本结构如图2.2所示。图2.2有助于理解在指令执行周期中进行交互的组件之间的关系。例如，从图中可以看到数据从内存传送到数据缓存、寄存器和ALU的流动路径。类似地，从图中还可以看出，算术逻辑单元和寄存器也可以直接读数据缓存。指令在执行之前被放入代码缓存，指令解码器从代码缓存读取指令并将读出的指令送给控制单元。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.2mou92nwacy0.webp)

### 多级流水线

指令执行周期中的每一步至少占用一个系统时钟滴答（也称为一个时钟周期）,但这并不意味着处理器在开始执行下一条指令之前必须等待所有步骤完成，处理器可以并行执行其他步骤，这就是流水线（pipelining)技术。Intel486处理器拥有6级流水线，这6级流水线以及它们的执行部件如下所示：

1. 总线接口单元（BIU,Bus InterfaceUnit):访问存储器并提供输入输出。
2. 代码预取单元（Code Prefetch Unit):从BIU接收机器指令并将其插入到称为指令队列的存储区域。
3. 指令解码单元（Instruction Decode Unit):对预取队列中的机器指令进行解码，将它们翻译成微代码。
4. 执行单元（Execution Unit):执行指令解码单元产生的微代码。
5. 分段部件（SegmentUnit):把逻辑地址转换为线性地址并进行保护检查。
6. 分页部件（Paging Unit):把线性地址转换为物理地址，进行页保护检查并保留一个最近访问页的列表。

例子：假设处理器内的每个执行阶段都需要一个时钟周期。图2.3中用表格表示了一个未使用流水线的处理器的6个执行阶段，这也是Intel486之前使用的模型。当指令I-1完成了S6阶段之后，指令I-2才开始，所以执行两条指令需要12个时钟周期。==换句话说，对于分为k个执行阶段的处理器，执行n条指令需要（nxk)个时钟周期。==

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.g83s222fuw0.webp)

**==流水线==**：图2.3所示的CPU的资源存在极大的浪费，因为每级的使用时间仅占总时间的1/6另一方面，如果处理器支持如图2.4所示的流水线，新的指令就可以在第二个时钟周期进入S1阶段，与此同时，第一条指令已经进入了S2阶段，这允许了指令的交选执行。图2.4所示的两条指令I-1和I-2在流水线中一起前进，I-1一进人S2阶段，I-2马上进入S1阶段，执行两条指令总共只需要7个时钟周期。当流水线满负荷时，所有6个阶段一直处于被使用的状态。

==一般对于k级的处理器来说，处理n条指令需要k+(n-1)个周期。==前面所示的未使用流水线的处理器处理两条指令需要12个周期，而使用流水线的处理器在同样的时间内可以处理7条指令。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.6zio1k819y40.webp)

### 超标量体系结构

==超标量（superscalar)或多核心处理器有两条以上的执行流水线，使得两条指令能够同时执行。==为了理解超标量处理器的优势，让我们重新考虑一下前面流水线的例子，例子中假设了S4阶段只需要单个指令周期，但这完全是一种简化，如果S4需要两个周期又会发生什么呢？如图2.5所示，这将会产生一种瓶颈效应。在图中，直到I-1完成S4阶段时I-2指令才能进入，因此1-2在进入S4阶段之前必须等待一个时钟周期。当更多的指令进入流水线时，就会产生更多浪费的周期（图中以灰色阴影表示）。==通常，对于k级（一个阶段需要两个周期）流水线，处理n条指令需要k+2n-1个时钟周期。==

==超标量处理器允许多条指令可同时处于执行阶段。对于n条流水线的情况，n条指令可以在同一时钟周期内并发执行。I==ntel奔腾处理器有两条流水线，它是IA-32系列中的第一个超标量处理器。奔腾Pro是第一个使用三条流水线的处理器。

假设S4阶段需要两个周期，图2.6显示了两条6级流水线执行指令的情况。在图2.6中，奇数编号的指令进入u流水线，偶数编号的指令进入v流水线，这就消除了对于时钟周期的浪费，==因此在k+n个周期内可以执行n条指令，这里k代表流水线的级数。==

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.50i8w0sp9cg0.webp)

## 2.1.3 内存的读取

==程序的吞吐量通常依赖于内存的访问速度。==例如，CPU的时钟频率可能是几吉赫兹（GHz),然而通过系统总线的内存访问却是以33MHz较慢速率进行的，这迫使CPU在开始执行指令之前要等待至少一个时钟周期，直到操作数从内存中取出为止。这些浪费的时钟周期称为等待状态(wait state)。

从内存中读取指令或数据需要若干个步骤，这是由CPU的内部时钟控制的。图2.7表明处理器时钟信号以固定的时间间隔上升和下降，在图中，时钟周期开始于时钟信号由高变低的时候，俗称下降沿，它代表了在状态之间进行转换所需要花费的时间。下面是读取内存时的每个时钟周期内所发生事情的简述：

- 周期1:内存操作数的地址位被放到地址总线（ADDR)上。
- 周期2:读取线（RD)设为低（0),以通知存储器要读一个值。
- 周期3:CPU等待一个周期，给存储器一些时间以做出响应。在这个时钟周期内，内存控制器把数据放在数据总线（DATA)上。
- 周期4:读取线（RD)变为1,通知CPU在数据总线（DATA)上读取数据。
- ==缓存（cache memory):由于常规内存与CPU相比是如此之慢，因此计算机使用高速缓存存放最近使用的指令和数据。程序第一次读取某块数据时，在缓存中将同时保留有一份副本。程序再次读取同样的数据时，首先在缓存内查找，如果缓存命中就表明数据已经在缓存中了，缓存未命中则表明数据不在缓存中，必须从常规内存中读取。==

通常，缓存对于改善内存访问速度效果明显，特别是在缓存较大时。==IA-32处理器有两种类型的缓存：一级缓存和二级缓存。与二级缓存相比，一级缓存比较小，但速度快，不过也比较昂贵。二级缓存过去一直是处理器外的独立存储，现在已经集成到处理器芯片内部了。==

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.1ibevgt1p44g.webp)

## 2.1.4 程序是如何运行的

### 加载和执行程序

下面的步骤按顺序描述了当用户在命令行提示符下运行一个程序时发生的事情：

- ==操作系统（OS)在当前磁盘目录中查找程序文件名，如果未找到的话，就在预先定义的目录列表（称为路径）中查找，如果操作系统还是找不到文件名，则显示一条错误信息==
- ==如果找到了程序文件名，操作系统获取磁盘上程序文件的基本信息，包括文件的大小以及在磁盘驱动器上的物理位置。==
- ==操作系统确定下一个可用内存块的地址，把程序文件装入内存，然后将程序的大小和位置等信息登记在一张表中（有时称为描述符表）。另外，操作系统或许还要调整程序内的指针值以便让它们指向正确的地址==
- ==操作系统执行一条分支转移指令，使CPU从程序的第一条机器指令开始执行。程序一旦开始运行，就称为一个进程。操作系统给进程分配一个标识数字（进程ID),用于在进程的运行期间对其进行跟踪。==
- ==这时进程自身已经开始运行，操作系统的任务是跟踪进程的执行并响应进程对系统资源的请求。举例来说，系统资源包括内存、磁盘文件和输入输出设备等==。
- ==进程终结时，其句柄被删除，进程使用的内存也被释放以便其他程序使用。==

> 如果读者使用的是Windows2000或WindowsXP,按下Ctrl-Alt-Delete组合键并单击“任务管理器”按钮，能够看到“应用程序”和“进程”标签页。应用程序列表列出了当前运行的程序的完整名称，如Windows Explorer和MicrosoftVisualC++等。单击“进程”标签时，可以看到包含30~40个名称的列表，可能其中的部分名称你并不熟悉。每个进程都是一个独立运行的小程序。注意，每个进程都有一个PID(进程ID)。可以持续跟踪观察程序占用的CPU时间和使用的内存数量。这些进程中的大部分都在后台运行而并不可见，可以关闭一个因出错但仍然在运行的进程。当然，如果错误地关闭了某些进程，计算机可能会停止运行，此时将不得不重启系统。

### 多任务

多任务操作系统能够同时运行多个任务，一个任务可以是一个程序（进程）或一个执行线程。一个进程拥有自己的内存并且可能包含多个线程。一个进程内的所有线程共享进程的内存空间。例如，游戏程序分别使用独立的线程同时控制多个图形对象；Web浏览器分别使用独立的线程同时加载图像并响应用户的输入。

大多数现代操作系统同时执行与硬件进行交互、用户界面显示、后台文件处理等多个任务。由于CPU实际上一次只能执行一条指令，因此一个称为调度程序（scheduler)的操作系统部件为每个任务分配一小部分CPU时间（称为时间片）。在一个时间片之内，CPU执行一系列指令，在时间片结束的时候停止执行。

通过快速的任务切换，操作系统给人以处理器同时运行多个任务的假象。操作系统使用的一种调度模型，称其为循环调度（round-robin scheduling)。在图2.8中有9个活跃的任务，随便假设调度程序为每个任务分配100ms,任务切换花费8ms,那么所有任务执行完一轮需要972ms[(9×100)+(9×8)]。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.7c7fxc0n5340.webp)

多任务操作系统运行在支持任务切换（task switching)的处理器上。对于每个任务，处理器在切换到另外一个任务之前保存当前任务的状态。任务状态包含处理器寄存器、程序计数器、状态标志以及任务所使用的内存内容。多任务的操作系统通常为任务分配不同的优先级，并据此为任务分配相对较大或较小的时间片。抢占式多任务操作系统（如Windows XP或Linux)允许高优先级的任务打断低优先级的任务，以使系统更加稳定。假设一个应用程序陷入了循环死锁，停止了对输入进行响应，键盘处理程序（一个高优先级的操作系统任务）能够响应用户的Ctrl-Alt-Del命令并终止有问题的应用程序。

# 2.2 IA-32处理器体系结构

如前所述，IA-32是指始于Intel386直到当前最新的奔腾4的系列处理器，在IA-32的发展过程中，Intel处理器的内部体系结构已经做了无数的改进，如流水线、超标量、分支预测以及超线程等。不过就编程而言，可见的变化只有用于多媒体处理以及用于图形计算的指令集扩展。

## 2.2.1 操作模式

IA-32处理器有三种基本的操作模式：

==保护模式、实地址模式和系统管理模式==。另外一种模式称为虚拟8086模式，是保护模式的一个特例。下面是每种操作模式的简要描述。保护模式（Protected Mode):保护模式是处理器的基本模式，在保护模式下，所有指令和特性都是可用的，程序被赋予了独立的内存区域（称为段）,处理器阻止程序访问已分配段之外的其他内存。

==虚拟8086模式（Virtual-8086Mode)==:在保护模式下，处理器可以在安全的多任务环境中执行实地址模式的软件，如MS-DOS程序。换句话说，即使一个MS-DOS程序崩溃了或试图向系统内存区写入数据，也不会影响同时运行的其他程序。Windows XP可以同时执行多个虚拟8086任务。

==实地址模式（Real-address Mode):==实地址模式实现了Intel8086处理器的程序设计环境以及其他一些新增的特性，如切换到其他两种模式的能力等。该模式在Windows98下是被支持的可用于运行那些需要直接访问系统内存和硬件设备的MS-DOS程序。实地址模式下运行的程序有可能导致操作系统挂起（停止响应命令）

==系统管理模式（SMM,System Management Mode):==系统管理模式为操作系统提供了用以实现电源管理和系统安全等功能的机制。这些功能通常是由那些想自定义特定的系统启动过程的计算机制造商实现的。

## 2.2.2 基本执行环境

### 地址空间

在保护模式下，IA-32处理器可访问高达4GB的内存，这是32位无符号二进制整数地址的能够寻址的上限。实地址模式程序只能访问1MB的内存。如果处理器处于保护模式并在虚拟8086模式下运行多个程序，每个程序都能访问独立的1MB内存区域。

### 基本寄存器

寄存器是CPU内部的高速存储单元，访问速度比常规内存快得多。例如，当对循环进行速度优化时，就可以把循环计数存放在寄存器而不是（内存）变量中。

图2.9列出了所有的用于程序执行的基本寄存器，其中有==8个通用寄存器，6个段寄存器，一个处理器状态标志寄存器（EFLAGS)和一个指令指针（EIP)寄存器。==

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.17x1wpxh6mm8.webp)

==通用寄存器==：通用寄存器主要用于算术运算和数据的传送。如下图所示，每个寄存器都可以作为一个32位值或两个16位值来寻址使用：

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.7gvwwxi84t00.webp)

==某些16位的寄存器能按8位值寻址使用==。例如，32位的EAX寄存器的低16位称为AX,AX寄存器的高8位称为AH,低8位称为AL。

EAX,EBX,ECX和EDX寄存器都存在这种交迭的关系：

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.2ee02p56ffb4.webp)

**==特殊用法==**：某些通用寄存器有些特殊的用法。

- ==EAX在乘法和除法指令中被自动使用。通常称为扩展累加寄存器==。

- 在某些指令中，==CPU自动使用ECX作为循环计数器==。


- ==ESP寻址堆栈（一种系统内存结构）上的数据==，极少用于普通的算术运算和数据传送，==通常称之为扩展堆栈指针寄存器。==

- ==ESI和EDI由高速内存数据传送指令使用，通常称为扩展源指针和扩展目的指针寄存器==

- ==高级语言使用EBP引用堆栈上的函数参数和局部变量==。除非用于高级程序设计技巧中EBP一般不应该用于普通算术运算和数据传送。==通常称为扩展帧指针寄存器。==

==段寄存器==：==实地址模式下，段寄存器用于存放段的基址，==段是一块预分配的内存区域。==保护模式下，段寄存器存放段描述符表的指针（索引）==。有些段存放程序的指令（代码）,有些则存放变量（数据）,另外还有其他的段（名为堆栈段）存放着函数的局部变量和函数参数。

==指令指针==：==EIP(或称为指令指针）寄存器存放下一条要执行的指令的地址==。有些机器指令可以修改EIP,使程序分支转移到新的地址执行。

==EFLAGS寄存器==：==EFLAGS(或Flags)寄存器由控制CPU的操作或反映CPU某些运算的结果的独立二进制位构成。==有些机器指令可以测试和修改单个处理器标志。

当某标志等于1时就说其被置位；等于0时就说其清除（或复位）。

==控制标志==：==控制标志控制CPU的操作==。例如，某些控制标志可使CPU在每条指令执行后、检测到算术运算溢出后、进入虚拟8086模式或保护模式后中断。

程序可以通过设置EFLAGS的单个位来控制CPU的操作。例如，设置方向标志位和中断标志位。

==状态标志==：==状态标志反映了CPU执行的算术和逻辑运算的结果，包括溢出标志、符号标志、零标志、辅助进位标志、奇偶标志和进位标志。==下列标志的名字后面列出了其对应的简写：

- ==进位标志（CF):==在无符号算术运算的结果太大而目的操作数无法容纳时置位。
- ==溢出标志（OF)==:在有符号算术运算的结果太大或太小而目的操作数无法容纳时置位。
- ==符号标志（SF)==:在算术或逻辑运算的结果为负时置位
- ==零标志（ZF)==:在算术或逻辑运算的结果为零时置位。
- ==辅助进位标志（AC)==:在算术运算导致8位操作数的位3到位4产生进位时置位。
- ==奇偶标志（PF)==:结果的最低有效字节为1的位的数目为偶数时置位，否则PF复位。通常PF标志位用于在数据有可能被改变或丢失的情况下进行错误检查。

### 系统寄存器

IA-32处理器有若干重要的系统寄存器。MS-Windows仅允许运行在最高特权级（特权级0)上的程序访问这些寄存器。操作系统内核就是这样的程序。这些寄存器如下：

- ==中断描述符表寄存器==（IDTR,Interrupt Descriptor Table Register):==保存中断描述符表地址，中断描述符表提供了一种方式用于处理中断==（用于响应如键盘和鼠标等事件的系统过程）。
- ==全局描述符表寄存器==（GDTR,Global Descriptor Table Register):保存全局描述符表的地址，全局描述符表包含了任务状态段和局部描述符表的指针（索引）
- ==局部描述符表寄存器==（LDTR,Local Descriptor Table Register):保存当前正在运行的程序的代码段、数据段和堆栈段的指针。
- ==任务寄存器==（Task Register):保存当前执行任务的任务状态段（TSS,task state segment)的地址调试寄存器（Debug Register):用于在调试程序时设置断点等
- ==控制寄存器==（Control Register)CRO,CR2,CR3:包含用于控制系统级操作（如任务切换、分页、允许缓存等）的状态标志和数据域。
- ==模型专用寄存器==（Model-Specific Registers):用于性能监控和机器体系结构检查等系统级操作。对于不同的IA-32处理器，可用的模型专用寄存器和使用方法都有可能不同。

本书将在第11章讲述保护模式内存管理时讨论GDTR和LDTR。应用程序不能访问系统寄存器，由于本书重点讲述汇编语言应用程序，因此将不使用系统寄存器。

## 2.2.3 浮点单元

IA-32浮点单元（FPU)执行高速浮点算术运算。过去浮点单元需要一块独立的协处理器芯片，但从Intel486以后，FPU被集成到了主处理器芯片中。

FPU内有8个浮点数据寄存器，名为ST(0),ST(1),ST(2),ST(3),ST(4),ST(5),ST(6)和ST(7),其余的控制和指针寄存器如图2.10所示。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.1wzdksqypcyo.webp)

其他寄存器

这里顺便再提及两套奔腾系列处理器中用于高级多媒体程序设计的寄存器：

- MMX指令集使用的8个64位寄存器。
- 单指令、多数据操作（SIMD,single-instruction,multiple-data)使用的8个128位XMM寄存器。

## 2.2.4 Intel 微处理器的历史

我们从IBM-PC首次发布时开始简单回顾一下微处理器的历史，那时个人计算机（PC)只有64KB内存且没有硬盘

==**Intel 8086:**==Intel8086(诞生于1978年）处理器标志着现代Intel体系结构的开端。8086与早期的处理器相比，其创新在于使用了16位的寄存器和16位的数据总线，并且采用了分段内模型，允许程序寻址最多1MB的内存。内存访问范围的增大使得编写复杂的商业程序成为可能IBM-PC是在1980年发布的，它包含一枚Intel8088处理器，除了数据总线是8位的以外，这种处理器的其余部分和8086是相同的，这使它生产起来稍微便宜一点。现在，Intel8088用于低成本的微控制器中。

> 向下兼容：自8086以后，新的Intel系列处理器与早期的处理器都是向下兼容的。这使得老软件可以无须修改即可在新的计算机上运行，需要更先进的处理器的某些特性的新软件终究会出现。

Intel80286:最早用在IBM-PC/AT计算机上的Intel80286处理器树立起了速度和性能的新标准，它是第一个运行于保护模式下的Intel处理器。80286使用24位地址线，可寻址16MB的内存。

### IA-32处理器系列

Intel386是IA-32系列的第一个成员，它引入了32位寄存器、32位的地址总线以及32位外部数据通道。IA-32系列处理器可寻址比物理内存大得多的虚拟内存空间，每个程序都被分配了4GB的线性地址空间。

Intel486:Intel486是IA-32系列的延续，其特点在于指令集的微结构采用了流水线技术，允许同时处理多条指令。

奔腾（Pentium):奔腾处理器性能改进较多，采用了两条并行流水线的超标量设计，允许条指令同时解码执行。奔腾处理器使用32位的地址线和64位的内部数据通道，在IA-32系列中引入了MMX技术。

P6处理器系列

1995年引入的P6系列的处理器基于新的微结构设计，提升了执行速度。P6系列扩展了基的IA-32体系结构。P6系列包括奔腾Pro(高能奔腾）、奔腾Ⅱ和奔腾III。奔腾Pro加入了提升指令执行速度的高级技术；奔腾II加入了MMX技术；奔腾引引入了SIMD(流扩展）技术，以及特别设计的用于快速移动大量数据的128位的寄存器。

奔腾4和至强（Xeon)系列奔腾4和至强处理器使用Intel的NetBurst微架构，与先前的IA-32系列相比，处理器可以以更高的速度进行操作。此外还针对高性能的多媒体应用程序进行了优化。一些更先进的奔腾4处理器采用了超线程（hyperthreading)技术，可以并行执行多线程应用程序。

### CISC和RISC

==Intel 8086是第一个使用CISC(复杂指令集计算机，Complex Instruction Set Computer)设计的处理器。CISC指令集很大，包含多种内存寻址、移位、算术运算、数据移动和逻辑操作。==复杂指令集使得编译后的程序可以包含相对较少的指令。==CISC设计的一个主要缺点是：对于复杂指令，处理器需要较长的时间解码和执行。CPU内部使用微代码编写的解释器解码并执行每条机器指令。==Intel一旦发布了8086,所有后续的Intel处理器都要与这第一个发布的处理器兼容，因为在新处理器发布时用户还不想丢弃他们已有的软件。

另外一种完全不同的微处理器设计方法称为==RISC(精简指令集计算机，Reduced InstructionSet Computer)。RISC包含数量相对较少的简短指令，执行非常快速。RISC并不使用微代码解释器解码和执行机器指令，而是使用硬件直接解码和执行指令。==使用RISC处理器的高速工程和图形工作站已经存在很多年了，不过遗憾的是，这些系统由于生产数量太少而一直过于昂贵。

由于IBM-PC兼容机的大量流行，Intel能够降低处理器的价格并支配微处理器市场。Inte也意识到了RISC技术的许多优点，并在其奔腾系列处理器中采用类RISC的技术（如流水线和超标量）。与此同时，IA-32指令集仍旧复杂无比，而且还一直在扩充。

# 2.3 IA-32的内存管理

IA-32处理器根据2.2.1节讨论的几种不同的基本操作模式对内存进行不同方式的管理。==保护模式是最简单也是最强大的，其他模式通常仅在程序需要直接访问系统硬件时才使用==。

==在实地址模式下，处理器只能寻址1MB的内存空间，地址是从十六进制数的00000~FFFFF处理器一次只能运行一个程序，但可以随时打断（称为中断）程序的执行以便处理来自外围设备的请求。==应用程序能够读取和修改RAM(随机访问存储器）的任何区域，能够读取ROM(只读存储器）的任何区域但不能修改。MS-DOS操作系统运行于实地址模式下，Windows95/98可以启动或切换到该模式

==在保护模式下，处理器可同时运行多个程序，并为每个进程（运行的程序）分配4GB的内存。可以为每个程序分配属于自己的保留内存区域，一个程序不能偶然访问其他程序的代码和数据。==MS-Windows和Linux都运行于保护模式下

在==虚拟8086模式下，实际上是处理器在保护模式下创建了一个有1MB地址空间的虚拟机，虚拟机对运行于实地址模式下的80x86计算机进行模拟==。例如，在Windows NT和Windows 20下，打开一个命令行窗口时就创建一个了8086虚拟机。可以同时运行很多这样的窗口，它们之间的行为不会互相影响。有一些直接访问计算机硬件的MS-DOS程序不能在Windows NT和Windows2000的虚拟8086模式下运行。

在接下来的两小节中（2.3.1节和2.3.2节）,我们将解释实地址模式和保护模式的细节，如果读者想要更加深入地研究该主题，一个很好的资源是三卷本的《IA-32 Intel体系结构软件开发人员手册》（IA-32 Intel Architecture Software Developer's Manual),读者可以从Intel的网站(www.intel.com)阅读或下载该手册。

## 2.3.1 实地址模式

在实地址模式下时，IA-32处理器使用20位的地址线，可以访问1048576字节的内存（1MB),地址范围是从十六进制数的0~FFFFF。==Intel工程师必须解决一个最基本的问题：8086处理器的16位的寄存器不能存放20位的地址。他们提出了一种称为分段内存的解决方案，所有的内存被分成多个64KB的区域，这些区域称为段==（segment),如图2.11所示。

或许可以用一幢大楼打比方，其中段代表楼层。一个人可以乘电梯到达指定的楼层，下电梯，然后开始按照房间号来定位查找某个房间。房间的偏移可以想像成电梯到房间的距离

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.376xcr9n4sa0.webp)

再次看图2.11,注意每个段都是从最后一个十六进制数位为0的地址开始的，由于这一点，在表示段值的时候，最后一个0就被省略了，例如，段值C000是指从地址C0000开始的段。在此图中，还能看到从80000h开始的段的展开图要定位该段内的任意一个字节，需要在段的基地址上再加上一个16位偏移值（0~FFFF)。如8000:0250表示从地址80000h开始的段内部偏移250h的地方，其线性地址是80250h

### 20位线性地址的计算

地址（address)用于指代内存中的某个位置，内存中的每个字节都有一个显式的地址。在实地址模式下，线性地址（linear address)或称为绝对地址（absolute address)是20位的，范围从十六进制数的0~FFFFF。程序无法直接使用线性地址，因此必须使用两个16位整数来表示，它们一起被称为段-偏移地址，包含如下两个部分：

- ==一个存放在段寄存器（CS,DS,ES或SS)中的16位段值==
- ==一个16位的偏移值==

==CPU自动把段-偏移地址转换成20位的线性地址，假设一个变量的段-偏移地址是08F:0100,CPU将段值乘以16(十六进制数是10),再把乘积同变量的偏移地址相加==：

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.7j2ooerqn780.webp)

==一个典型的程序有三个段：代码段、数据段和堆栈段。三个段寄存器CS,DS和SS包含着==

- ==CS包含一个16位的代码段地址==
- ==DS包含一个16位的数据段地址==
- ==SS包含一个16位的堆栈段地址。==
- ==ES,FS和GS可指向其他数据段。==

## 2.3.2 保护模式

保护模式是一个更加强大的处理器模式。==当处理器运行于保护模式下时，每个程序可以寻址4GB的内存，地址范围是从十六进制数的0~FFFFFFFF==。Microsoft汇编器中的==平坦（flat)内存模式（参见.MODEL伪指令）适合用于保护模式编程。平坦内存模式非常易于使用，因为只需要使用一个32位整数就可以存放任何指令和变量的地址。==处理器在后台进行地址的计算和转换，所有这一切对应用程序员都是透明的。==段寄存器（CS,DS,SS,ES,FS和GS)指向段描述符表，操作系统使用段描述符表定位程序使用的段的位置。一个典型的保护模式程序有三个段：代码段、数据段和堆栈段，使用CS,DS和SS三个段寄存器==：

- ==CS包含描述符表中的代码段描述符。==
- ==DS包含描述符表中的数据段描述符。==
- ==SS包含描述符表中的堆栈段描述符。==

### 平坦分段模式

==在平坦分段模式下，所有段都被映射到计算机的32位物理地址空间中。一个程序至少需要两个段：代码段和数据段。每个段都由一个段描述符定义，**段描述符通常是一个存放在全局描述符表（GDT,Global Descriptor Table)中的一个64位的值**==。图2.12给出了一个==**基地址域指向内存中第一个可用地址**（00000000)的段描述符，**段界限域可用于表示系统中物理内存的数量**==，在当前的图中，段界限是0040。访问类型域包含了规定段如何使用的数据位。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.3rgn5n9fqzu0.webp)

> 假设一台计算机有256MB的内存，某个段描述符表示所有可用的物理内存，那么段界限域将包含十六进制值10000，因为其值隐含地要乘以十六进制值1000，最终得到十六进制值10000000(256MB)。

### 多段模式

==在多段模式（multi-Segment model)下**，每个任务或程序都有自己的段描述符表，称为局部描述符表（LDT,Local Descriptor Table)**。每个描述符都可以指向一个与其他所有进程使用的段都不同的段，并且每个段都位于独立的地址空间中。==图2.13中，LDT的每个表项（段描述符）都指向内存中的一个不同的段，每个段描述符都指定了段的大小，例如从3000开始的段的大小是十六进制值2000,其计算过程为（十六进制数值）0002*1000,而从8000开始的段大小为十六进制数值A000。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.2f0qwghsh2fw.webp)

### 分页

IA-32处理器支持一种称为==分页（paging)的特性，允许一个段被分割成称为页（page)的4096字节的内存块==。==分页机制允许同时运行的程序使用的总内存远大于计算机的物理内存==。==操作系统映射的所有页的集合称为虚拟内存（virtual memory)。==操作系统通常包含一个名为虚拟内存管理器的实用程序。

==分页机制解决了一个一直困扰着软硬件设计者的难题：程序在运行前必须装入内存，但内存是非常昂贵的，用户总是想要在内存中装入大量程序并随意进行切换。==另一方面，磁盘存储是廉价而海量的，不过访问磁盘要比访问主存储器慢得多。分页机制（通过使用后备磁盘存储）会使人产生内存几乎是无限大的错觉。然而，一个程序越依赖于分页机制，其运行也就可能越慢。

当任务运行时，如果程序的一部分当前未被使用，那么这部分可以保留在磁盘上。任务的一部分可能已经被换页（交换）到磁盘上了，任务的其他部分，如当前活跃的执行代码用到的页，可以保留在内存中。当处理器开始执行已经被换页交换出主存的代码时，将产生一个页错误（pagefault)，这将导致包含有所需代码及数据的页被重新载入内存。要想观察分页机制导致的页交换读者可以找一台内存很少的计算机，并同时运行多个大型程序，读者应该能注意到从一个程序切换到另一个程序时会有明显的延迟，因为操作系统必须将每个程序交换出的部分从磁盘传输到主存。当安装了更多内存时，计算机会运行得更快，因为大型应用程序和文件可完全存放在内存中，这就减少了换页的数量。

# 2.4 IA-32微机的构成

本节从几个角度分别介绍IA-32计算机的体系结构。首先，我们从宏观层次上考察硬件（计算机的物理组成部分）以及外围设备；接下来考察Intel处理器（中央处理器，Central Processing Unit,简称CPU)的内部细节；最后将讨论软件的体系结构，也就是内存组织的方式以及操作系统如同硬件进行交互

## 2.4.1 主板

主板是微型计算机的心脏，主板是一块印制电路板，上面安装计算机的CPU、功能支持芯组、主存储器、输入输出接口、电源插口以及扩展槽。这些不同的组件通过总线相互连接，总线是印制在主板上的一组电线。PC市场上有种类繁多的主板，尽管它们在扩展能力、集成的组件和速度上有所差异，但是下面的一些部件是各种主板都具有的：

CPU插座，根据主板支持的处理器类型的不同，不同主板的CPU插座的形状和大小可能不同。

- 内存插槽，用于安装可插拔式内存卡。
- 基本输入输出系统（BIOS,Basic Input-Output System)芯片，存放着系统软件
- CMOS内存，带一块可充电电池供电。
- 海量存储设备（如硬盘和CD-ROM等）的接口。
- 外部设备的USB接口。
- 键盘和鼠标接口。
- PCI插槽，用于安装声卡、图形卡、数据采集卡和其他输入输出设备

下面一些部件是可选的：

- 集成的声卡处理器。
- 并口和串口
- 集成的网卡
- 高速视频卡使用的AGP总线接口。

下面是一个典型的IA-32系统中的一些重要的功能支持处理芯片：

- ==浮点单元（FPU)，处理浮点和扩展整数运算==。
- 8284/82C284==时钟发生器，简称为时钟==，它以固定的频率产生脉冲。时钟发生器用于在CPU和计算机其余部件之间进行同步
- ==8259A可编程中断控制器（PIC)==,处理来自外部设备的中断，如键盘、系统时钟和磁盘驱动器等。这些设备打断CPU的执行并使其立即处理它们的请求。
- ==8253可编程时钟/计数器每秒触发18.2次系统中断==，用于更新系统日期和时钟并控制扬声器。它还负责不断地刷新内存，因为RAM芯片记忆的数据只能保持几毫秒
- ==8255可编程并口，通过它可以和使用IEEE并行接口的计算机互相收发数据==。这种端口通常用于打印机，但也可以用于其他输入输出设备。

### PCI和PCIE总线体系结构

==PCI(外部组件互连，Peripheral Component Interconnect)总线用于连接CPU和其他系统设备==，如硬盘、内存、视频控制器、声卡和网络控制器等。最近的PCIE(PCIExpress)总线为设备、内存和处理器之间提供了双向串行连接。PCIE总线以类似网络的方式在独立的“通道”内通过报文传输数据。图形控制器大都支持PCIE总线，可以按大约4GB/s的速度传输数据

### 主板芯片组

大多数主板都包含一系列称为芯片组的集成微处理器或控制器。芯片组在很大程度上决定计算机的性能。这里列出的都是Intel公司的组件名字，但是许多主板使用其他制造商生产的兼容芯片组：

- ==Intel 8237直接内存访问==（DMA)控制器，它在外部设备和RAM之间直接传送数据，而不需要CPU做任何额外的工作。
- ==Intel 8259可编程中断控制器==，处理来自硬件的请求并产生CPU中断。
- ==8254时钟计数器每秒触发18.2次滴答==，处理系统时钟和日时钟，并作为内存刷新计时器使用。
- ==与PCI桥连接的微处理器局部总线==。
- 系统内存控制器和缓存控制器。
- ==PCI总线与ISA总线连接的总线桥==。
- ==Intel8042键盘和鼠标微控制器==

## 2.4.2 视频输出

视频适配器控制IBM兼容机上文本和图形的显示。它由两部分构成：视频控制器和视频显示存储器（显存）。显示在监视器上的所有文本和图形都要写入显存，然后由视频控制器送往监视器。视频控制器自身也是一个具有特殊用途的微处理器，它减轻了CPU控制视频显示硬件的工作量

阴极射线管（CRT,Cathode-ray tube)视频监视器使用一种称为光栅扫描的技术来显示图像电子束照亮屏幕上称为像素（pixel)的荧光点，电子枪从屏幕的最顶端开始从左到右进行扫描，然后关闭，并重新从左边的下一新行开始扫描，水平回扫指电子枪在行扫描之间关闭的时间。当绘制完最后一行的时候，电子枪关闭并移动到屏幕的左上角重新开始扫描（称为垂直回扫）。

数字液晶显示（LCD,Liquid Crystal Display)监视器直接从视频控制器接收数字位流而不需要光栅扫描。

## 2.4.3存储器

基于Intel的系统使用几种基本类型的存储器：只读存储器（ROM)，可擦写可编程只读存储器（EPROM)，动态随机访问存储器（DRAM)，静态随机访问存储器（SRAM)，视频随机访问存储器（VRAM)以及互补金属氧化物半导体随机访问存储器（CMOS RAM):

- ==ROM:只读存储器==，是内容被永久烧录到芯片中而不能擦除的存储器
- ==EPROM:可擦写可编程只读存储器==，只能使用紫外线低速擦除，可重新编程。
- ==DRAM:动态随机访问存储器，是在程序运行时存储代码和数据的地方，它必须在1ms之内被重新刷新，否则其中的内容就会丢失==。由于它价格低廉，因此计算机用它作为主存储器。一些系统使用ECC(错误检查和更正，error checking and correcting)内存。
- ==SRAM:静态随机访问存储器，也是一种RAM芯片，主要用于昂贵的高速缓存，这种存储器不需要重复刷新即可保持其内容==。CPU的缓存使用的就是SRAM。
- VRAM:视频随机访问存储器，专用于存储视频数据，VRAM是双端口的，它允许在一个端口不断读出数据刷新显示的同时从另一个端口写数据。
- CMOS RAM:互补金属氧化物半导体随机访问存储器，在系统主板上用于存储系统设置信息，它由一块电池供电，因此其中的内容即使在计算机电源关闭之后仍然可以保留。

## 2.4.4 输入输出接口

通用串行总线（USB,Universal Serial Bus):通用串行总线接口为计算机和其他支持USB的设备之间提供了智能、高速的连接。USB2.0支持480MB/s的数据传输速率。USB接口可以连接单功能设备（鼠标、打印机）或多个共享同一USB接口的复合设备。如图2.14所示的USB集线器就是可以同其他设备（包括集线器）连接的复合设备，图中的每根USB线缆都有两种接头：A=传回（upstream),B=传出（downstream)。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.2okvn4uaf600.webp)

当设备通过USB与计算机相连时，计算机询问（枚举）设备以获取其设备名、设备类型以及其支持的驱动程序类型，这个过程称为枚举。计算机可以切断单个设备的电源，使设备处于挂起状态。

### 并口

==大多数打印机都通过并行端口与计算机相连。术语“并行”意味着字节数据或字数据的所有位可以同时从计算机传送到设备，在通常不超过10英尺的较短距离内，数据可以非常快速（1MB/s)地传送。==MS-DOS自动识别三个并行端口：LPT1,LPT2和LPT3。并行端口可以是双向的，也就是说计算机通过并行端口既可以向设备发送数据也可以从设备接收数据。尽管许多打印机现在都使用USB接口了，高速连接许多实验仪器和定制设备时并口依然很有用。IDE:通常称为智能驱动设备接口或集成驱动设备。

IDE接口连接计算机和海量存储设备，如硬盘、DVD以及CD-ROM等。计算机内几乎总是存在IDE接口。当今的大部分设备实际上是并行ATA(Advanced Technology Attachment)设备，这类设备的驱动控制器在设备内。带内建控制逻辑的设备把CPU从内部逻辑的控制工作中解放出来了。另外一个相关的接口是SATA(SerialATA,串行ATA),提供了比并行ATA更高的数据传输速率。

### FireWire

==火线（FireWire)是一种高速外部总线标准==，支持最高达800MB/s的数据传输速率。大量设备可以附加到FireWire总线上，数据可以按指定的速率传输（同步数据传输）。

### 串口

==RS-232串行端口每次发送一个二进制位==，这导致其速度较并口和USB接口慢，但是这样使数据进行较远距离的传送成为可能。串口的最高数据传输速率是19200b/s。实验采集设备通常使用串口，调制解调器也是。控制串行端口的芯片是16550UART(通用异步收发器，UniversalAsynchronous Receiver Transmitter)。

# 2.5 输入输出系统

梦想过编写计算机游戏吗？游戏是内存和I/O密集应用的程序，常常可以将计算机的性能发挥到极限。优秀的游戏编写人员了解大量关于视频和音频硬件的细节，他们针对硬件的特性优化游戏程序的代码。

## 2.5.1所有这一切是如何工作的

应用程序通常从键盘和文件读取输入，并将输出写到屏幕或文件中。输入输出（I/O)不必通过直接访问硬件就能完成——相反，通过调用操作系统的功能函数就能完成。在不同的访问层次都可以进行I/O操作，这有点类似于第1章中讲述的虚拟机的概念。有三种基本的访问层次：

- 高级语言的功能函数：诸如C++或Java之类的高级程序设计语言包含了执行输入输出的函数。这些功能函数是可移植的，能够在多种不同的计算机系统上工作并且不依赖于任何一个操作系统。
- 操作系统：程序员可以通过API(应用编程接口，Appliacation Programming Interface)调用操作系统的功能函数。操作系统提供了一些高级操作，如写字符串到文件、从键盘读取字符串以及分配内存块等。
- BIOS(基本输入输出系统）:是直接同硬件设备交互的子程序的集合。BIOS是由计算机制造商安装的，同计算机硬件相匹配。操作系统通常同BIOS通信。

### 设备驱动程序：

如果计算机安装了BIOS不能辨别的新设备，会发生什么呢？当操作系统引导的时候，它加载一个设备驱动程序，设备驱动程序中包含了同设备通信的功能函数。设备驱动程序工作起来与BIOS非常相似，它为特定的设备或一类设备提供了输入输出的功能。一个例子是CD-ROM.SYS,它允许MS-DOS读取CD-ROM驱动器。

应用程序在屏幕上显示一个字符串时的步骤如下所示，可以把I/O访问层次画成一张图，参见图2.15:

1. 一条应用程序语句调用一个高级语言库函数向标准输出上写字符串。
2. 库函数（层次3)调用一个操作系统函数，传递一个字符串指针
3. 操作系统函数（层次2)进入一个循环，循环中调用BIOS的某个子例程，向它传递每个字符的ASCII码及其颜色，操作系统调用另外一个BIOS子例程把光标前进到屏幕上的下一个字符要显示的位置。
4. BIOS子例程（层次1)接收每个字符，映射特定的系统字体，然后把字符送至与视频控制卡相连的硬件端口。
5. 视频控制卡（层次0)定时产生硬件信号给视频显示以控制光栅扫描和像素显示。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.213yjb1r2g0w.webp)

在多个层次上进行编程：在输入输出程序设计领域，汇编语言的能力和灵活性更大，如图2.16所示，汇编语言程序可以从下面的访问层次中进行选择。

- 层次3:调用库函数执行通用的文本I/O和基于文件的I/O,如本书就提供了这样一个库。
- 层次2:调用操作系统函数执行文本I/O和基于文件的I/O。如果操作系统使用图形用户界面，会有一些与设备无关的方式显示图形的函数。
- 层次1:调用BIOS功能控制与设备相关的特性，如颜色、图形、声音、键盘输入和底层磁盘I/O等。
- 层次0:在硬件层次上接收和发送数据，能够完全控制特定的设备。

![image](https://github.com/YangLuchao/img_host/raw/master/root/image.1rjtsmp9cz34.webp)

什么是折中呢？可控制性和可移植性就是一个最基本的例子。比如层次2(OS)可在任何运行同样操作系统的计算机上工作，如果特定的I/O设备缺乏特定的功能，OS就会尽量以其他的方式进行处理以达到想要的结果。层次2并不很快，因为每次I/O调用在执行之前都必须穿越几个层次。

层次1(BIOS)可在任何有标准BIOS的系统上工作，但是在不同系统上不一定能够产生同样的结果，例如，两台计算机或许有不同分辨率的视频显示器。层次1的程序员必须编写代码侦测用户的硬件配置并调整输出格式以进行匹配。层次1运行得比层次2快速，因为它仅仅比硬件层高一层。

层次0(硬件）可在串口等通用设备或知名制造商生产的特定设备上工作。使用这个层次的程序必须增加编码逻辑以处理I/O设备的各种不同之处。实地址模式游戏程序是最基本的例子，因为它们通常接管计算机的所有操作。这个层次的程序可以以硬件允许的最高速度执行。

例如假设你要使用音频控制设备播放WAV文件。在操作系统层，不必知道安装的是什么类型的设备，也无须过多关心声卡可能具有的非标准特性。在BIOS层次就不得不查询声卡（使用安装的设备驱动程序）并找出其是否属于某类具有已知特性的声卡。而在硬件层次的话，就必须调整程序以适应特定品牌的声卡，利用每种声卡的特性。

最后，必须指出并不是所有的操作系统都允许用户程序直接访问系统硬件，这种访问权限往往保留给操作系统自身以及特定的设备驱动程序。在Windows NT/2000/XP下就是如此，重要的系统资源受到保护，它同应用程序之间是隔离的，相反，MS-DOS就没有这样的限制。

# 2.6本章小结

==中央处理器（CPU)是所有计算和逻辑操作发生的地方，它包含了有限数量的称为寄存器的存储单元，另外还有一个用于同步操作的高频时钟，一个控制单元以及一个算术逻辑单元。==

==内存存储单元是计算机程序运行时存放指令和数据的地方。==

==总线是在计算机不同部件之间传送数据的一组并行线==

==单条指令的执行可分成一系列的独立操作，称为指令执行周期。==

==三种基本操作是取指令、解码和执行。指令执行周期中的每一步花费至少一个系统时钟滴答，称为一个时钟周期。==

==加载和执行程序的步骤描述了操作系统如何定位程序文件、载入内存以及如何执行的过程。==

==流水线执行通过允许多阶段指令的交迭执行，极大地提高了CPU处理指令的吞吐量。==

==超标量处理器是多流水线执行的处理器，在当指令执行的某阶段需要多个时钟周期时特别有用==

==多任务操作系统能够同时运行多个任务，它必须在支持任务切换的处理器上运行，也就是说系统在切换到新任务之前必须能够保存原任务的状态。==

==IA-32处理器有三种基本的操作模式：保护模式、实地址模式和系统管理模式。此外，虚拟8086模式是保护模式的特例。==

==寄存器是CPU内部的命名单元，可以比常规内存高得多的速度进行访问。==下面是寄存器类型的简短描述：

- ==通用寄存器主要用于算术运算、数据传送和逻辑操作==
- ==段寄存器用于存放段的基地址，段是一块预分配的内存区域。==
- ==EIP(指令指针）寄存器包含下一条要执行指令的地址。==
- ==EFLAGS(扩展标志）寄存器由控制CPU操作或反映算术逻辑单元输出结果的二进制位构成。==

IA-32处理器有一个特别用于执行高速浮点算术运算的浮点单元（FPU)。

Intel 8086处理器标志着现代Intel系列体系结构的开端。第一个IA-32系列的处理器是Intel386处理器，它使用32位寄存器、32位地址总线及外部数据通道。P6系列处理器（奔腾Pro以上）基于新的微体系结构设计，它能提升指令执行的速度

IBM个人计算机使用的最早的Intel处理器是基于复杂指令集（CISC)的。Intel指令集包含强大的数据寻址方式，并且包含相对高层的可以执行复杂操作的指令。另外一种完全不同的微处理器体系是精简指令集（RISC)。RISC机器语言由数量相对较少的简短指令构成，可由处理器快速执行。

==在实地址模式下，处理器只能寻址1MB的内存，地址范围是从00000到FFFF。==

==在保护模式下，处理器可同时运行多个程序。保护模式下为每个进程（运行的程序）分配总共4GB的虚拟内存。==

==在虚拟8086模式下，计算机运行于保护模式并创建具有1MB地址空间的8086虚拟机，可对运行于实地址模式下的80x86计算机进行模拟。==

==在平坦分段模式下，所有段都映射到计算机的同一物理地址空间中。==

==在多段模式下，每个任务都有自己的段描述符表，称为局部描述符表（LDT)。==

==IA-32支持一种称为分页的特征，允许段分成称为页的大小为4096字节的内存块。分页机制允许同时运行的程序使用的内存总量比计算机的实际（物理）内存大得多。==

主板是微型计算机的心脏，主板安放着计算机的CPU,功能支持芯片，主存储器，输入输出接口，电源插槽以及扩展槽。PCI(外部组件互连）总线为奔腾处理器的升级提供了方便。大多数主板都包含了若干集成的微处理器和控制器，称为芯片组。芯片组在很大程度上决定了计算机的性能。

视频适配器控制IBM兼容机的文本和图形显示。它有两个组件：视频控制器和视频显示内存。

PC中使用几种基本类型的内存：ROM,EPROM,动态RAM(DRAM),静态RAM(SRAM),视频RAM(VRAM)和CMOS RAM。

通用串行总线（USB)接口为计算机和支持USB的设备之间提供了一种智能、高速的连接。

并口从一个设备向另一个设备同时传送8位或16位数据。

RS-232串行端口一次发送一个二进制位，这就使得串口的传送速度比并口和USB设备慢。

输入输出是通过不同的访问层次完成的，这有点类似于虚拟机的概念，其中操作系统在高层。BIOS(基本输入输出系统）是直接同硬件设备交互的子功能的集合，程序也可以直接访问输入输出设备。
